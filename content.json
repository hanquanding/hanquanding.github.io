{"meta":{"title":"Hexo","subtitle":"","description":"","author":"hqd8080","url":"https://hqd8080.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-12-21T09:17:39.793Z","updated":"2022-12-21T09:17:39.793Z","comments":false,"path":"about/index.html","permalink":"https://hqd8080.github.io/about/index.html","excerpt":"","text":"计算机软件工程专业； 10年多互联网开发经验；6年多Golang使用经验； 对IT领域的软件开发和设计工作有浓厚兴趣，喜欢新技术，关注新技术发展； 熟练使用Golang进行项目开发，有多年实际开发经验；理解goroutine和channel、理解Go语言的并发模型； 熟练使用Go生态的Web框架Gin、Beego、Iris、gRPC进行项目研发；WebSocket、TCP/IP、HTTP/HTTPS、ProtoBuf、JSON； 熟练使用MySQL数据库、有MySQL设计、数据库建模、和SQL性能优化经验、有分库、分表、分区等实际经验； Redis、NSQ、Kafka、RabbitMQ； 有微服务开发经验、go-zero、go-micro；Etcd、Consul分布式中间件；OpenTracing、Jaeger、Zipkin； Docker、Dockerfile、Docker-composer；Kubernetes； Linux、Shell、Git; Java、SSM、SpringBoot、SpringCloud、Maven、Mybatis、Mybatis-Plus、JPA； 区块链、Ethereum、EOS、Hyperledger Fabric、PoW、 PoS、DPoS、PBFT；能使用Solidity编写智能合约；NFT；"},{"title":"分类","date":"2022-09-26T14:03:28.861Z","updated":"2021-08-21T14:55:23.000Z","comments":false,"path":"categories/index.html","permalink":"https://hqd8080.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-26T14:03:28.861Z","updated":"2021-08-24T04:39:40.000Z","comments":false,"path":"tags/index.html","permalink":"https://hqd8080.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Go语言的并发控制","slug":"golang/go-goroutine","date":"2022-04-01T14:09:10.000Z","updated":"2022-11-20T07:23:57.047Z","comments":true,"path":"2022/04/01/golang/go-goroutine/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-goroutine/","excerpt":"","text":"Go语言的并发控制Go语言原生支持的三种常用并发控制有Channel、WaitGroup、Context等； ① Channel：使用chan控制子协程； ② WaitGroup：使用信号量机制控制子协程； ③ Context：使用上下文控制子协程； 三种方式各有优缺点： Channel的优点是：实现简单，流程清晰易懂； WaitGroup的优点是：子协程数可动态调整； Context的优点是：对子协程派生出来的孙子协程的控制； Channel使用chan控制子协程chan是Go语言原生支持的通道类型、用于协程之间的通信；也可以用于并发控制； 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;time&quot;)// channel 并发控制func main() &#123; channels := make([]chan int, 10) // 创建一个包含10个元素的切片，元素类型为channel for i := 0; i &lt; 10; i++ &#123; // 在切片中放入一个channel channels[i] = make(chan int) // 启动协程，传入一个管道用于通信 go Process(channels[i]) &#125; // 遍历切片，等待子协程结束 for i, ch := range channels &#123; &lt;-ch fmt.Println(&quot;routine &quot;, i, &quot; quit!&quot;) &#125;&#125;func Process(ch chan int) &#123; // do some work... time.Sleep(time.Second * 1) // 在管道中写入一个元素、表示当前协程已结束 ch &lt;- 1&#125; Go语言生产者和消费者的例子 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;// 消费者func consumer(data chan int, done chan bool) &#123; // 接收数据，直到通道被关闭 for v := range data &#123; fmt.Println(&quot;recv:&quot;, v) &#125; // 通知main消费结束 done &lt;- true&#125;// 生产者func producer(data chan int) &#123; for i := 0; i &lt; 4; i++ &#123; // 发送数据 data &lt;- i &#125; // 生产结束，关闭通道 close(data)&#125;func main() &#123; done := make(chan bool) // 用于接收消费者结束信号 data := make(chan int) // 数据管道 go consumer(data, done) // 启动消费者 go producer(data) // 启动生产者 &lt;-done // 阻塞，直到消费者发回结束信号&#125; 使用Channel并发控制的总结： 使用Channel控制子协程的优点是：实现简单； 缺点是：当需要大量创建子协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制； WaitGroup使用信号量机制（等待组）控制子协程WaitGroup是Go应用开发中经常用的并发控制技术；WaitGroup对外提供了三个接口： ① Add(delta int)：将delta值加到counter中； ② Wait：阻塞等待信号量； ③ Done：counter递减1，按照waiter数值释放响应次数的信号量； 注意： Add操作必须早于Wait()，否则会触发panic； Add设置的值必须与实际等待的goroutine的个数一致，否则会触发panic； 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)func main() &#123; var wg sync.WaitGroup wg.Add(2) go func() &#123; // do some work time.Sleep(time.Second) fmt.Println(&quot;finished!&quot;) wg.Done() &#125;() go func() &#123; // do some work time.Sleep(time.Second) wg.Done() &#125;() wg.Wait() fmt.Println(&quot;ok&quot;)&#125; Context使用上下文控制子协程Go语言的Context是开发中经常用到的并发控制技术；它与WaitGroup最大的不同点是： context对于派生goroutine有更强的控制力，它可以控制多级的goroutine；context翻译成中文是”上下文”； 源码：src/context/context.go:Context定义了该接口： 123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 一个典型的cancel context使用例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go HandelRequest(ctx) time.Sleep(time.Second * 5) fmt.Println(&quot;its time to stop all sub goroutine!&quot;) cancel() time.Sleep(time.Second * 5)&#125;func HandelRequest(ctx context.Context) &#123; go WriteRedis(ctx) go WriteDatabase(ctx) for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;HandelRequest Done.&quot;) return default: fmt.Println(&quot;HandelRequest running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125;func WriteRedis(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;WriteRedis Done.&quot;) return default: fmt.Println(&quot;WriteRedis running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125;func WriteDatabase(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;WriteDatabase Done.&quot;) return default: fmt.Println(&quot;WriteDatabase running.&quot;) time.Sleep(time.Second * 2) &#125; &#125;&#125; 12345678910111213WriteDatabase running.WriteRedis running.HandelRequest running.HandelRequest running.WriteRedis running.WriteDatabase running.WriteDatabase running.WriteRedis running.HandelRequest running.its time to stop all sub goroutine!HandelRequest Done.WriteRedis Done.WriteDatabase Done.","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的内存管理和垃圾回收（GC）","slug":"golang/go-stw","date":"2022-04-01T13:10:10.000Z","updated":"2022-12-17T08:31:13.360Z","comments":true,"path":"2022/04/01/golang/go-stw/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-stw/","excerpt":"","text":"Go语言的内存管理和垃圾回收（GC）Go语言使用三色标记法回收内存 Go语言的GC是自动管理内存的机制，垃圾回收器会尝试回收程序不再使用的对象和占用的内存 常见垃圾回收算法： 1.引用计数 2.标记-清除 Go 3.分代收集 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象优点：对象可以很快被回收缺点：不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价代表语言：php，python 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的变量被回收优点：解决引用计数的缺点，不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价的缺点缺点：暂停程序的执行代表语言：Go （三色标记法） 分代收集按照对象生命周期的长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率优点：收回性能好缺点：算法复杂代表语言:java Go的垃圾回收Go垃圾回收的原理是，标记出哪些内存还在使用中，（即被引用到），哪些内存不在使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时再使用缺点就是，不是实时的回收内存，而是暂停程序的执行去处理内存回收 三色标记法这里的三色是对应了垃圾回收过程中对象的三种状态1.灰色：对象还在标记队列中等待2.黑色：对象已经被标记(该对象不会在本次GC中被清理)3.白色：对象未被标记(该对象会在本次GC中被清理) Go的STWGo中的STW（Stop The World）就是停止所有的goroutine，专心做垃圾回收，待垃圾回收结束后，再恢复goroutine,STW的长短直接影响了程序的性能 垃圾回收优化1.写屏障就是让goroutine与GC同时运行的手段，GC过程中新分配的内存会被立即标记，即本轮不回收，下次GC时再确定 2.补助GC使用goroutine参与一部分的GC工作来提高性能 垃圾回收的触发时机1.内存分配量达到阈值触发GC每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值则立即触发GC阈值 = 上次GC内存分配量 X 内存增长率内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC 2.定期触发GC默认情况下，最长两分钟触发一次GC 3.手动触发使用 runtime.GC() 来手动触发GC主要用于GC的性能测试和统计 逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定 在函数中申请一个新的对象：如果分配在栈中，则函数执行结束后，可自动将内存回收如果分配在堆中，则函数执行结束后可交给GC（垃圾回收）处理 1.逃逸策略在函数中申请新的对象时，编辑器会根据该对象是否被函数外部引用来决定是否逃逸：如果函数外部没有引用，则优先放在栈中如果函数外部存在引用，则必定存放在堆中 注意：对于仅在函数内部使用的变量，也有可能存放在堆中，比如内存过大，超过栈的存储能力 使用interface类型存在逃逸的可能（动态类型逃逸）闭包引用对象逃逸","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的通道、管道类型（chan）","slug":"golang/go-channel","date":"2022-04-01T12:10:10.000Z","updated":"2022-12-22T10:10:05.840Z","comments":true,"path":"2022/04/01/golang/go-channel/","link":"","permalink":"https://hqd8080.github.io/2022/04/01/golang/go-channel/","excerpt":"","text":"Go语言的通道、管道类型（chan）chan通道、管道类型的数据结构： 12345678910111213141516171819202122// 源码来自Go 1.19// 源码包：src/runtime/chan.go type hchan struct &#123; qcount uint // 当前队列中剩余的元素个数 dataqsiz uint // 环形队列长度、即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 关闭标示字段 elemtype *_type // 元素类型 sendx uint // 队列下标、元素写入时存放在队列中的位置 recvx uint // 队列下标、指示下一个被读取的元素在队列中的位置 recvq waitq // 等待读消息的协程队列 sendq waitq // 等待写消息的协程队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G&#x27;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex // 互斥锁、保证chan并发安全操作&#125; 通道、管道类型是Go在语言层面提供的协程间的通信方式、也可以用于并发控制； Go语言的通道、管道类型实现互斥锁12345678910var counter int = 0var ch = make(chan int, 1)func Work() &#123; ch &lt;- 1 // 写入 counter++ &lt;-ch // 读取&#125;// 只有一个缓冲区的通道、写入数据类似于加锁、读取数据类似释放锁 通道、管道数据读写通道、管道没有缓冲区时，从管道读取数据会阻塞，直到有协程向管道中写入数据；类似的，向通道、管道写入数据也会阻塞，直到有协程从管道读取数据； 内置函数len()查询通道、管道缓冲区中数据的个数；内置函数cap()查询缓冲区的大小； 123456789func myChan() &#123; ch := make(chan int, 10) ch &lt;-1 ch &lt;-2 fmt.Println(len(ch)) // 2 fmt.Println(cap(ch)) // 10&#125; 通道、管道实现了一种FIFO（先入先出）的队列、数据总是按照写入的顺序流出管道； 单项管道的使用例子123456789101112131415func readChan(chanName &lt;-chan int) &#123; data:= &lt;- chanName fmt.Println(data)&#125;func writeChan(chanName chan&lt;- int) &#123; chanName &lt;- 1 &#125;func main() &#123; var mychan = make(chan int, 10) writeChan(mychan) readChan(mychan)&#125; 通道、管道 + select监控多个协程的执行情况123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; var ch1 = make(chan int, 10) var ch2 = make(chan int, 10) go work(ch1) go work(ch2) for&#123; select&#123; case e:=&lt;-ch1: fmt.Printf(&quot;get element from ch1:%d\\n&quot;, e) case e:=&lt;-ch2: fmt.Printf(&quot;get element from ch2:%d\\n&quot;, e) default: fmt.Println(&quot;no element in ch1 and ch2!&quot;) time.Sleep(time.Second * 1) &#125; &#125;&#125;func work(ch chan int) &#123; for&#123; ch &lt;-1 time.Sleep(time.Second * 1) &#125; &#125; select在main中监控多个协程的执行情况；case的执行顺序是随机的（伪随机算法）实现I/O多路复用；","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的时间类型（time）","slug":"golang/go-time","date":"2022-03-31T15:10:10.000Z","updated":"2022-12-22T10:11:09.158Z","comments":true,"path":"2022/03/31/golang/go-time/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-time/","excerpt":"","text":"Go语言的时间类型（time）12345678910111213141516171819202122232425// 源码来自Go 1.19// 源码包：/usr/local/go/src/time/time.gotype Time struct &#123; // wall and ext encode the wall time seconds, wall time nanoseconds, // and optional monotonic clock reading in nanoseconds. // // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic), // a 33-bit seconds field, and a 30-bit wall time nanoseconds field. // The nanoseconds field is in the range [0, 999999999]. // If the hasMonotonic bit is 0, then the 33-bit field must be zero // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext. // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit // unsigned wall seconds since Jan 1 year 1885, and ext holds a // signed 64-bit monotonic clock reading, nanoseconds since process start. wall uint64 ext int64 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // The nil location means UTC. // All UTC times are represented with loc==nil, never loc==&amp;utcLoc. loc *Location&#125; wall：表示距离公元 1 年 1 月 1 日 00:00:00UTC 的秒数;ext：表示纳秒;loc：代表时区，主要处理偏移量，不同的时区，对应的时间不一样; 公认最准确的计算应该是使用“原子震荡周期”所计算的物理时钟了（Atomic Clock, 也被称为原子钟），这也被定义为标准时间（International Atomic Time） 而我们常常看见的 UTC（Universal Time Coordinated，世界协调时间）就是利用这种 Atomic Clock 为基准所定义出来的正确时间。UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差UTC + 时区差 ＝ 本地时间 国内一般使用的是北京时间，与 UTC 的时间关系如下：UTC + 8 个小时 = 北京时间 在Go语言的 time 包里面有两个时区变量，如下： time.UTC：UTC 时间 time.Local：本地时间 获取当前时间我们可以通过time.Now()函数来获取当前的时间对象，然后通过事件对象来获取当前的时间信息 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; now := time.Now() //获取当前时间 fmt.Printf(&quot;current time:%v\\n&quot;, now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&quot;%d-%02d-%02d %02d:%02d:%02d\\n&quot;, year, month, day, hour, minute, second)&#125; 时间操作函数我们在日常的开发过程中可能会遇到要求某个时间 + 时间间隔之类的需求，Go语言中的 Add 方法实现func (t Time) Add(d Duration) Time 12345678910package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; now := time.Now() later := now.Add(time.Hour) // 当前时间加1小时后的时间 fmt.Println(later)&#125; 求两个时间之间的差值func (t Time) Sub(u Time) Duration 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较func (t Time) Equal(u Time) bool 如果t代表的时间点在u之前，返回真；否则返回假func (t Time) Before(u Time) bool 如果t代表的时间点在u之后，返回真；否则返回假func (t Time) After(u Time) bool 定时器使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel） 123456func TestTick() &#123; ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器 for i := range ticker &#123; fmt.Println(i)//每秒都会执行的任务 &#125;&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的异常处理类型、异常处理机制defer、recover、panic（error）","slug":"golang/go-error","date":"2022-03-31T14:10:10.000Z","updated":"2022-12-21T10:45:38.740Z","comments":true,"path":"2022/03/31/golang/go-error/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-error/","excerpt":"","text":"Go语言的异常处理Go语言的异常处理和Java、PHP语言的try…catch不一样！Go是使用内置的error来处理错误，用panic和recover来处理异常； panic抛出异常、这个异常直接回导致程序崩溃暂停程序的执行，官方建议并发程序中慎用！ defer捕获异常、defer延迟执行、实现类似栈的”先进后出”的数据结构、一般defer后面直接和匿名函数+recover来捕获和处理异常； recover恢复异常处理！recover必须和defer直接调用才有效，否则永远返回nil（编程陷阱）！","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的接口类型（interface）","slug":"golang/go-interface","date":"2022-03-31T13:10:10.000Z","updated":"2022-11-19T08:29:32.241Z","comments":true,"path":"2022/03/31/golang/go-interface/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-interface/","excerpt":"","text":"Go语言的接口类型（interface）","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的结构体类型、使用组合实现OOP（struct）","slug":"golang/go-struct","date":"2022-03-31T12:10:10.000Z","updated":"2022-12-22T10:19:53.016Z","comments":true,"path":"2022/03/31/golang/go-struct/","link":"","permalink":"https://hqd8080.github.io/2022/03/31/golang/go-struct/","excerpt":"","text":"Go语言的结构体类型、使用组合实现面向对象（struct）Go语言的struct和其他语言的class有些类似；","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的字典类型Map、以及并发安全的sync.Map类型（map）","slug":"golang/go-map","date":"2022-03-30T13:10:10.000Z","updated":"2022-12-22T10:17:05.459Z","comments":true,"path":"2022/03/30/golang/go-map/","link":"","permalink":"https://hqd8080.github.io/2022/03/30/golang/go-map/","excerpt":"","text":"Go语言的字典类型Map、以及并发安全的sync.Map类型（map）Go语言的map类型底层使用Hash表实现；（无序集合）； map类型的数据结构： 123456789101112131415// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/map.gotype hmap struct &#123; count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125; map类型的增、删、改、查1234567891011func mapCURD() &#123; m := make(map[string]string, 10) m[&quot;apple&quot;] = &quot;red&quot; // 添加 m[&quot;apple&quot;] = &quot;green&quot; // 修改 delete(m, &quot;apple&quot;) // 删除 val, exist := m[&quot;apple&quot;] // 查询 if exist &#123; fmt.Println(&quot;apple - %s\\n&quot;, val) &#125; &#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的切片类型、数组和切片的区别（slice）","slug":"golang/go-slice","date":"2022-03-30T12:10:10.000Z","updated":"2022-12-22T10:11:09.160Z","comments":true,"path":"2022/03/30/golang/go-slice/","link":"","permalink":"https://hqd8080.github.io/2022/03/30/golang/go-slice/","excerpt":"","text":"Go语言的切片类型、数组和切片的区别切片slice、也叫动态数组； 切片的数据结构: 1234567// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/slice.gotype slice struct &#123; array unsafe.Pointer // 底层数组 len int // 切片的长度 cap int // 切片的容量&#125; 切片和数组的区别 ①、切片是指针类型，数组是值类型 ②、数组的长度是固定的，而切片长度可以自动扩容（切片是动态的数组） ③、数组只有长度一个属性，而切片比数组多了一个容量（cap)属性 ④、切片的底层也是数组实现的 切片的扩容规则 ①、如果原slice的容量小于1024，则新slice的容量将扩大为原来的2倍； ②、如果原slice的容量大于或等于1024，则新slice的容量将扩大为原来的1.25倍； 切片的使用例子声明、初始化切片 12// 变量声明var s []int 123// 字面量声明s1 := []int&#123;&#125;s2 := []int&#123;1, 2, 3&#125; 123// 使用内置函数make创建s1 := make([]int, 12) // 指定长度s2 := make([]int, 10, 100) // 指定长度和空间 基于数组创建切片例子123456array := [5]int&#123;1,2,3,4,5&#125;s1 := array[0:2] // 1 2s2 := array[0:1] // 1fmt.Println(s1)fmt.Println(s2)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的数组类型（array）","slug":"golang/go-array","date":"2022-03-29T04:10:10.000Z","updated":"2022-12-22T09:40:54.798Z","comments":true,"path":"2022/03/29/golang/go-array/","link":"","permalink":"https://hqd8080.github.io/2022/03/29/golang/go-array/","excerpt":"","text":"Go语言的数组类型（array）","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的字符串类型（string）","slug":"golang/go-string","date":"2022-03-29T02:10:10.000Z","updated":"2022-12-22T10:11:09.162Z","comments":true,"path":"2022/03/29/golang/go-string/","link":"","permalink":"https://hqd8080.github.io/2022/03/29/golang/go-string/","excerpt":"","text":"Go语言的字符串类型string是Go语言的基本数据类型 string的数据结构： 123456// 源码来自Go 1.19// 源码包：/usr/local/go/src/runtime/string.gotype stringStruct struct &#123; str unsafe.Pointer // 首地址 len int // 字符串长度&#125; 1.string可以为空（长度为0），但不会是nil; 2.string对象不可以修改； 字符串类型常用类型转换项目中经常需要在string和字节切片[]byte之间转换 123456// string to []bytefunc stringToByte() &#123; s:= &quot;Hello&quot; b:= []byte(s) fmt.Pringln(b) // [72 101 108 108 111]&#125; 123456// []byte to stringfunc byteToString() &#123; b:= []byte(&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;) s:= string(b) fmt.Pringln(s) // Hello&#125; 常用字符串函数（标准库函数）1func Contains(s, substr string) bool // 检查字符串s中是否包含子串substr 1func Split(s, sep string) []string // 将字符串s，根据分隔符sep拆分并生成子串的切片 1func Join(elems []string, sep string) string // 将字符串切片elems中的元素，使用分隔符sep拼接成单个字符串 1func HasPrefix(s, prefix string) bool // 检查字符串s中是否包含前缀prefix 1func HasSuffix(s, suffix string) bool // 检查字符串s中是否包含后缀缀suffix 1func ToUpper(s string) string // 将字符串s中的所有字符转换成大写 1func ToLower(s string) string // 将字符串s中的所有字符转换成小写 1func Trim(s string, cutset string) string // 清除字符串s首部和尾部cutset中的字符 1func TrimSpace(s string) string // 清除字符串s首部和尾部所有空白字符 1func Replace(s, old, new string, n int) string // 字符串替换，将字符串s的前n个子串中的old替换成子串new 1func ReplaceAll(s, old, new string) string // 将字符串s中的所有子串old替换成子串new 1func EqualFold(s, t string) bool // 忽略大小写、比较两个子串是否相等","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言统一接口响应格式","slug":"golang/go-response","date":"2022-03-28T02:10:10.000Z","updated":"2022-11-19T08:07:54.438Z","comments":true,"path":"2022/03/28/golang/go-response/","link":"","permalink":"https://hqd8080.github.io/2022/03/28/golang/go-response/","excerpt":"","text":"自己封装统一api接口响应格式，使用Gin框架的项目可直接使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @Author: hqd8080 * @Description: response,响应处理 * @Date: 2022-03-28 10:53 */package respimport ( &quot;go-vueadmin/pkg/errcode&quot; &quot;github.com/gin-gonic/gin&quot;)// Response 统一格式返回type Response struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// PaginationParam 分页参数type PaginationParam struct &#123; List interface&#123;&#125; `json:&quot;list&quot;` Count int64 `json:&quot;count&quot;` PageIndex int `json:&quot;page_index&quot;` PageSize int `json:&quot;page_size&quot;`&#125;// PageResponse 分页统一格式type PageResponse struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data PaginationParam `json:&quot;data&quot;`&#125;// Correct 正常返回数据,无分页func Correct(c *gin.Context, httpCode int, errCode int, data interface&#123;&#125;) &#123; response := &amp;Response&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: data, &#125; c.JSON(httpCode, response)&#125;// CorrectOK 正常返回分页数据func CorrectOK(c *gin.Context, httpCode int, errCode int, data interface&#123;&#125;, count int64, pageIndex int, pageSize int) &#123; pagination := PaginationParam&#123; List: data, Count: count, PageIndex: pageIndex, PageSize: pageSize, &#125; response := &amp;PageResponse&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: pagination, &#125; c.JSON(httpCode, response)&#125;// ErrorCode 可以定制返回错误码，错误信息func ErrorCode(c *gin.Context, httpCode int, errCode int) &#123; response := &amp;Response&#123; Code: errCode, Msg: errcode.GetErrorMsg(errCode), Data: nil, &#125; c.JSON(httpCode, response)&#125; 公共错误码标准化定义/pkg/errcode/errcode.go/pkg/errcode/errmsg.go 12345678910111213141516171819202122/** * @Author: hqd8080 * @Description: errcode,公共错误码标准化 * @Date: 2022-03-28 09:43 */package errcodeconst ( ErrCodeSuccess = 2000 // 公共错误码、成功 ErrCodeError = 5000 // 公共错误码、服务端错误 ErrCodeInvalidParam = 4000 // 公共错误码、请求参数错误 // 轮播图模块 ErrBannerList = 10000 ErrBannerExist = 10001 ErrBannerNotFound = 10002 ErrBannerCreate = 10003 ErrBannerUpdate = 10004 ErrBannerUpdateStatus = 10005 ErrBannerDelete = 10006) 123456789101112131415161718192021222324252627282930/** * @Author: hqd8080 * @Description: errmsg,公共错误码标准化 * @Date: 2022-03-28 10:07 */package errcodevar ErrorMsg = map[int]string&#123; ErrCodeSuccess: &quot;ok&quot;, ErrCodeError: &quot;fail&quot;, ErrCodeInvalidParam: &quot;请求参数错误！&quot;, // 轮播图模块 ErrBannerList: &quot;获取轮播图列表失败！&quot;, ErrBannerExist: &quot;轮播图已经存在！&quot;, ErrBannerNotFound: &quot;轮播图不存在！&quot;, ErrBannerCreate: &quot;添加轮播图失败！&quot;, ErrBannerUpdate: &quot;更新轮播图失败！&quot;, ErrBannerUpdateStatus: &quot;修改轮播图状态失败！&quot;, ErrBannerDelete: &quot;删除轮播图失败！&quot;,&#125;func GetErrorMsg(code int) string &#123; msg, ok := ErrorMsg[code] if ok &#123; return msg &#125; return ErrorMsg[ErrCodeError]&#125; 使用123456789101112131415161718192021222324252627package adminimport ( &quot;go-vueadmin/models&quot; &quot;go-vueadmin/pkg/errcode&quot; &quot;go-vueadmin/pkg/resp&quot; &quot;go-vueadmin/service&quot; &quot;go-vueadmin/util&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)type BannerImageController struct &#123; BaseController&#125;func (b BannerImageController) GetBannerImageList(c *gin.Context) &#123; bannerService := service.NewBannerImageService() pageIndex := bannerService.GetPageIndex(c) pageSize := bannerService.GetPageSize(c) list, count, err := bannerService.BannerList(c, pageIndex, pageSize) if err != nil &#123; resp.ErrorCode(c, http.StatusOK, errcode.ErrBannerList) return &#125; resp.CorrectOK(c, http.StatusOK, errcode.ErrCodeSuccess, list, count, pageIndex, pageSize)&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"GORM 2.0使用教程","slug":"golang/go-gorm2","date":"2022-03-21T02:54:40.000Z","updated":"2022-11-19T08:09:28.916Z","comments":true,"path":"2022/03/21/golang/go-gorm2/","link":"","permalink":"https://hqd8080.github.io/2022/03/21/golang/go-gorm2/","excerpt":"","text":"GORM 2.0使用教程GORM1.X用过有一段时间了，感觉Go生态MySQL的ORM还是不太成熟的，有一些特性使用起来还是觉得不太顺手，GORM算是比较好用的了，目前使用的人也比较多 这是main.go项目初始化1234567891011121314func init() &#123; if err := initialize.InitConfig(); err != nil &#123; panic(err) &#125; if err := initialize.InitLogger(); err != nil &#123; panic(err) &#125; if err := initialize.InitDB(); err != nil &#123; panic(err) &#125; if err := initialize.InitRedis(); err != nil &#123; panic(err) &#125;&#125; 这是GORM初始化的代码，注意GORM 2.0，Tag是2.0,实际上目前的版本还是1.23.x的版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @Author: hqd8080 * @Description: mysql * @Date: 2022-03-21 09:30 */package initializeimport ( &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;time&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot; &quot;gorm.io/gorm/logger&quot; &quot;gorm.io/gorm/schema&quot;)var DB *gorm.DBfunc InitDB() error &#123; var err error dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;, DatabaseConfig.Username, DatabaseConfig.Password, DatabaseConfig.Host, DatabaseConfig.Port, DatabaseConfig.Name, ) config := mysql.New(mysql.Config&#123; DriverName: &quot;mysql&quot;, // mysql DSN: dsn, // dsn SkipInitializeWithVersion: false, // 根据版本自动配置 DefaultStringSize: 256, // 设置string类型字段的默认长度 &#125;) logger := logger.New(log.New(os.Stdout, &quot;\\r\\n&quot;, log.LstdFlags), logger.Config&#123; SlowThreshold: time.Second * 1, // 慢SQL阈值 Colorful: true, // 开启彩色打印 IgnoreRecordNotFoundError: false, // 忽略未找到记录错误 LogLevel: logger.Info, // 设置日志级别 &#125;, ) opts := &amp;gorm.Config&#123; DisableForeignKeyConstraintWhenMigrating: true, // 迁移时禁用外键约束 PrepareStmt: true, Logger: logger, // 日志配置 NamingStrategy: schema.NamingStrategy&#123; TablePrefix: &quot;t_&quot;, // 设置表前缀 SingularTable: true, // 使用单数表名 NameReplacer: nil, NoLowerCase: false, &#125;, &#125; db, err := gorm.Open(config, opts) if err != nil &#123; return fmt.Errorf(&quot;connection to db err:%v&quot;, err) &#125; sqlDB, err := db.DB() if err != nil &#123; return fmt.Errorf(&quot;get db conn err:%v&quot;, err) &#125; sqlDB.SetMaxOpenConns(int(DatabaseConfig.MaxOpenConn)) // 打开数据库连接的最大数量 sqlDB.SetConnMaxIdleTime(time.Hour) // sqlDB.SetMaxIdleConns(int(DatabaseConfig.MaxIdleConn)) // 空闲连接池中连接的最大数量 sqlDB.SetConnMaxLifetime(time.Hour) // 连接可复用的最大时间 DB = db log.Println(&quot;init db connection success&quot;) return err&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gorm","slug":"gorm","permalink":"https://hqd8080.github.io/tags/gorm/"}]},{"title":"Docker安装Redis并配置密码详细教程","slug":"docker/docker-install-redis","date":"2022-02-17T03:37:28.000Z","updated":"2022-03-31T03:23:07.000Z","comments":true,"path":"2022/02/17/docker/docker-install-redis/","link":"","permalink":"https://hqd8080.github.io/2022/02/17/docker/docker-install-redis/","excerpt":"","text":"Docker安装Redis并配置密码详细教程 执行以下命令，查找docker官方提供的最新的redis镜像：1docker search redis --filter &quot;is-official=true&quot; 将官方Redis镜像拉取到本地1docker pull redis 执行以下命令，根据Redis镜像生成本地容器1docker run --name myredis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass &quot;123456&quot; -d 设置docker容器在后台运行-p 6379:6379 设置端口映射，前者为本地端口，后者为docker容器端口-v d:/redisdata:/data 将容器中/data目录映射到本地d:\\redisdata目录,作为redis数据持久化的存储目录redis-server –appendonly yes 启用aof持久化方式 执行以下命令，根据Redis镜像生成本地容器,添加目录映射1docker run --name myredis redis:latest -d -p 6379:6379 -v d:\\redisdata:/data redis-server --appendonly yes --requirepass &quot;123456&quot; 查看镜像1docker ps","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Nginx配置HTTPS详细教程","slug":"nginx/nginx-ssl","date":"2022-02-17T02:37:28.000Z","updated":"2022-11-19T08:11:34.090Z","comments":true,"path":"2022/02/17/nginx/nginx-ssl/","link":"","permalink":"https://hqd8080.github.io/2022/02/17/nginx/nginx-ssl/","excerpt":"","text":"Nginx配置HTTPS详细教程 前置条件：在配置https之前请确保下面的步骤已经完成 服务器已经安装nginx并且通过http可以正常访问 拥有ssl证书，没有的可以去阿里购买或者免费申请一年 ，如果以上条件都满足了，接下来开始配置https 第一步：Nginx的ssl模块安装在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不会存在ssl模块的这里先检查下自己是否存在ssl模块：进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的进入到目录的sbin目录下，输入: 12# 注意这里是大写的V，小写的只显示版本号nginx -V 如果出现 (configure arguments: --with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行ssl配置步骤) 一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/usr/local/src/nginx），进入目录后，输入： 1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行: 12make# 切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件 接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务 1234nginx -s stop # 停止nginx服务# 替换之前的nginxcp /usr/local/src/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl信息是否编译成功 123# 注意这里是大写的V，小写的只显示版本号nginx -V # 可以看到这里出现了configure arguments: --with-http_ssl_module证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 第二步：配置ssl证书解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改） 将下载好的证书上传到服务器，我将证书放在了/data/web/目录下的ssl文件夹 12# 创建ssl文件夹mkdir -p /data/web/ssl 第三步：进行nginx.conf配置进入nginx.conf文件下 123cd /usr/locla/nginx/conf# 修改nginx.conf文件vim nginx.conf 打开之后文件内容如图: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117user www;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 可以将没用的东西都删除掉，删除的时候注意，括号要对应起来 进入servers/website.conf然后进行配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server &#123; listen 443 ssl; server_name hqd8080.me; ssl on; ssl_certificate /data/web/ssl/hqd8080.me.pem; ssl_certificate_key /data/web/ssl/hqd8080.me.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; root /data/web/public; access_log /data/web/logs/hqd8080.me.access.log; error_log /data/web/logs/hqd8080.me.error.log; client_max_body_size 10m; location / &#123; index index.html index.htm; &#125; location ~ ^/(uploads|assets)/.*\\.(php|php5|jsp)$ &#123; deny all; &#125; # 配置后台服务api接口服务 代理到8080端口 location ~ ^/dev/ &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; rewrite ^/dev/(.*)$ /$1 break; proxy_pass http://127.0.0.1:8080; &#125; error_page 404 /404.html; error_page 403 /403.html;&#125;server &#123; listen 80; server_name hqd8080.me; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent;&#125; 注意：这里需要在安全组中开放443端口 第四步：重启nginxok，如果上述步骤都完成了，没有问题，接下来只需要重启nginx服务即可 进入sbin目录下，输入: 123./nginx -s reload./nginx -s stop./nginx 完成","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/categories/Nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://hqd8080.github.io/tags/nginx/"}]},{"title":"Linux系统SSH隧道与端口转发及内网穿透","slug":"linux/linux-ssh","date":"2021-11-30T07:30:28.000Z","updated":"2022-04-02T02:57:24.000Z","comments":true,"path":"2021/11/30/linux/linux-ssh/","link":"","permalink":"https://hqd8080.github.io/2021/11/30/linux/linux-ssh/","excerpt":"","text":"Linux系统SSH隧道与端口转发及内网穿透#/usr/bin/sshpass -p dbuser /usr/bin/ssh -N -f -L 3307:10.141.96.240:3306 root@121.41.118.64 -o ExitOnForwardFailure=yes 说明：需要安装sshpass 3307:10.141.96.240:3306 // 从10.141.96.240服务器上的3306数据库转发到3307端口 root@121.41.118.64 // 我本地能直接访问的服务器用户名和服务器ip地址 dbuser //数据库用户名 然后就能在本地愉快的玩远程不能直接链接的数据库了 mysql -h127.0.0.1 -udbuser -pdbpass -P3307 举个例子比如，我们有1台web服务器（内网ip: 192.168.1.101,外网ip:123.123.123.123），1台db服务器（内网ip: 192.168.1.102, 无外网ip)这时，我想从我本地连接到数据库 ssh -N -f -L 3307:192.168.1.102:3306 123.123.123.123mysql -uuser -ppasswd -h127.0.0.1 -P3307 就可以连接到数据库了 在需要保持连接的情况下，多次重复建立隧道会出现警告，但是不会退出当前进程，结果就会出现多个ssh进程，加上下面这个参数后，会在创建失败后将当前进程自动退出，适合在crontab中让ssh保持与服务端的连接 -o ExitOnForwardFailure=yes","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"gRPC使用实例","slug":"grpc/grpc-demo","date":"2021-11-29T07:30:30.000Z","updated":"2022-03-29T05:44:07.000Z","comments":true,"path":"2021/11/29/grpc/grpc-demo/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/grpc/grpc-demo/","excerpt":"","text":"首先使用gRPC先定义protobuf协议文件hello.proto 12345678910111213141516syntax = &quot;proto3&quot;;package services;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 2;&#125;service HelloService &#123; rpc SayHello(HelloRequest) returns (HelloReply); rpc Streaming(stream HelloRequest) returns (stream HelloReply);&#125; user.proto 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130syntax = &quot;proto3&quot;;package services;// 测试官方类型import &quot;google/protobuf/timestamp.proto&quot;;import &quot;google/protobuf/empty.proto&quot;;import &quot;google/protobuf/any.proto&quot;;//import &quot;common.proto&quot;;// 测试枚举类型enum LoginStatus &#123; success = 0; // 登录成功 failed = 1; // 登录失败 error = 2; // 错误&#125;// 用户登录请求message UserLoginRequest &#123; int64 user_id = 1; // 用户编号 string user_name = 2; // 用户名 string user_nickname = 3; // 用户昵称 string user_country = 4; // 用户国籍 int32 user_gender = 5; // 用户性别 double user_credits = 6; // 用户积分 bool is_admin = 7; // 是否是管理员 bytes auth_code = 8; // 授权码 float user_balance = 9; // 用户余额 // 用户爱好 enum Hobby &#123; music = 0; // 音乐 basketball = 1; // 篮球 tour = 2; // 旅游 &#125; Hobby user_hobby = 10; // 用户爱好 repeated int32 lucky_numbers = 11; // 幸运数字 map&lt;string, string&gt; user_email = 12; // 用户email map&lt;string, int32&gt; user_weight = 13; // 用户体重 map&lt;string, PhoneNumber&gt; user_num = 14; // 测试map LoginStatus login_status = 15; // 登录状态 // 手机类型枚举 enum PhoneType &#123; mobile = 0; // 移动 home = 1; // 家庭 work = 2; // 办公室 &#125; // 手机号码类型 message PhoneNumber &#123; string phone_number = 1; // 手机号码 PhoneType phone_type = 2; // 手机号码类型 &#125; repeated PhoneNumber phones = 16; // 手机号码 google.protobuf.Timestamp last_update_date = 17; // 最后更新日期&#125;// 用户登录响应message UserLoginResponse &#123; int64 user_id = 1; // 用户编号 string user_name = 2; // 用户名 string user_pwd = 3; // 用户密码 int32 user_gender = 5; // 用户性别 double user_credits = 6; // 用户积分 bool is_admin = 7; // 是否是管理员 bytes auth_code = 8; // 授权码 float user_balance = 9; // 用户余额 // 用户爱好 enum Hobby &#123; music = 0; // 音乐 basketball = 1; // 篮球 tour = 2; // 旅游 &#125; Hobby user_hobby = 10; // 用户爱好 // 手机类型 enum PhoneType &#123; mobile = 0; // 移动 home = 1; // 家庭 work = 2; // 办公室 &#125; // 手机号码类型 message PhoneNumber &#123; string phone_number = 1; // 手机号码 PhoneType phone_type = 2; // 手机号码类型 &#125; repeated PhoneNumber phones = 11; // 手机号码 google.protobuf.Timestamp last_update_date = 12; // 最后更新日期 map&lt;string, PhoneNumber&gt; user_num = 13; // 测试map repeated int32 lucky_numbers = 14; // 幸运数字 map&lt;string, string&gt; user_email = 15; // 用户email map&lt;string, int32&gt; user_weight = 16; // 用户体重 LoginStatus login_status = 17; // 登录状态&#125;message TestRequest &#123; string name = 1; repeated Extension extensions = 2;&#125;message TestResponse &#123; string msg = 1; string name = 2; repeated Extension extensions = 3;&#125;message Extension &#123; uint64 id = 1; google.protobuf.Any data = 2; //测试官方any类型&#125;// user serviceservice UserService &#123; rpc Login(UserLoginRequest) returns (UserLoginResponse); rpc LoginStreaming(stream UserLoginRequest) returns (stream UserLoginResponse);&#125;// test serviceservice TestService &#123; rpc Test(TestRequest) returns (TestResponse); rpc Ping (google.protobuf.Empty) returns (google.protobuf.Empty);&#125; common.proto 123456789syntax = &quot;proto3&quot;;package services;enum LoginStatus &#123; success = 0; // 登录成功 failed = 1; // 登录失败 error = 3; // 错误&#125; 根据protobuf文件生成pb文件generate.sh 12#!/bin/bashprotoc -I. --go_out=plugins=grpc:../services/pb *.proto 实现接口协议services/hello.go 12345678910111213141516171819202122232425262728293031323334package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot;)type HelloService struct&#123;&#125;func (h *HelloService) SayHello(ctx context.Context, request *pb.HelloRequest) (*pb.HelloReply, error) &#123; reply := &amp;pb.HelloReply&#123;Message: &quot;hello &quot; + request.GetName()&#125; return reply, nil&#125;func (h *HelloService) Streaming(stream pb.HelloService_StreamingServer) error &#123; for &#123; req, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; return nil &#125; return err &#125; reply := &amp;pb.HelloReply&#123;Message: &quot;hello &quot; + req.GetName()&#125; err = stream.Send(reply) if err != nil &#123; return err &#125; return nil &#125;&#125; services/user.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot;)type UserService struct&#123;&#125;func (u *UserService) Login(ctx context.Context, request *pb.UserLoginRequest) (*pb.UserLoginResponse, error) &#123; var phones = []*pb.UserLoginResponse_PhoneNumber&#123; &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;返回手机号码:&quot; + request.GetPhones()[0].PhoneNumber, PhoneType: pb.UserLoginResponse_PhoneType(request.GetPhones()[0].PhoneType), &#125;, &#125; var userNum = map[string]*pb.UserLoginResponse_PhoneNumber&#123; &quot;phone_001&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginResponse_mobile, &#125;, &quot;phone_002&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginResponse_home, &#125;, &quot;phone_003&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginResponse_work, &#125;, &#125; reply := &amp;pb.UserLoginResponse&#123; UserId: request.GetUserId(), UserName: &quot;获取用户名称：&quot; + request.GetUserName(), UserPwd: &quot;用户密码12345678900&quot;, UserGender: request.GetUserGender(), UserCredits: request.GetUserCredits(), IsAdmin: request.GetIsAdmin(), AuthCode: request.GetAuthCode(), UserBalance: request.GetUserBalance(), UserHobby: pb.UserLoginResponse_Hobby(request.GetUserHobby()), Phones: phones, LastUpdateDate: request.GetLastUpdateDate(), UserNum: userNum, LuckyNumbers: request.GetLuckyNumbers(), UserEmail: request.GetUserEmail(), UserWeight: request.GetUserWeight(), LoginStatus: request.GetLoginStatus(), &#125; return reply, nil&#125;// 双向流func (u *UserService) LoginStreaming(stream pb.UserService_LoginStreamingServer) error &#123; for &#123; req, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; return nil &#125; return err &#125; var phones = []*pb.UserLoginResponse_PhoneNumber&#123; &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;返回手机号码:&quot; + req.GetPhones()[0].PhoneNumber, PhoneType: pb.UserLoginResponse_PhoneType(req.GetPhones()[0].PhoneType), &#125;, &#125; var userNum = map[string]*pb.UserLoginResponse_PhoneNumber&#123; &quot;phone001&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;1111111111&quot;, PhoneType: pb.UserLoginResponse_mobile, &#125;, &quot;phone002&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;2222222222&quot;, PhoneType: pb.UserLoginResponse_home, &#125;, &quot;phone003&quot;: &amp;pb.UserLoginResponse_PhoneNumber&#123; PhoneNumber: &quot;3333333333&quot;, PhoneType: pb.UserLoginResponse_work, &#125;, &#125; reply := &amp;pb.UserLoginResponse&#123; UserId: req.GetUserId(), UserName: &quot;返回用户名称：&quot; + req.GetUserName(), UserPwd: &quot;用户密码111111111111&quot;, UserGender: req.GetUserGender(), UserCredits: req.GetUserCredits(), IsAdmin: req.GetIsAdmin(), AuthCode: req.GetAuthCode(), UserBalance: req.GetUserBalance(), UserHobby: pb.UserLoginResponse_Hobby(req.GetUserHobby()), Phones: phones, LastUpdateDate: req.GetLastUpdateDate(), UserNum: userNum, LuckyNumbers: req.GetLuckyNumbers(), UserEmail: req.GetUserEmail(), UserWeight: req.GetUserWeight(), LoginStatus: req.GetLoginStatus(), &#125; err = stream.Send(reply) if err != nil &#123; return err &#125; return nil &#125;&#125; services/test.go 1234567891011121314151617181920212223242526272829303132333435package servicesimport ( &quot;context&quot; pb &quot;tests/grpc/services/pb&quot; &quot;strconv&quot; &quot;github.com/golang/protobuf/ptypes/empty&quot; anypb &quot;google.golang.org/protobuf/types/known/anypb&quot;)type TestService struct&#123;&#125;func (t *TestService) Test(ctx context.Context, req *pb.TestRequest) (*pb.TestResponse, error) &#123; var extension = []*pb.Extension&#123; &amp;pb.Extension&#123; Id: req.GetExtensions()[0].Id, Data: req.GetExtensions()[0].GetData(), &#125;, &amp;pb.Extension&#123; Id: 100, Data: &amp;anypb.Any&#123;TypeUrl: &quot;test any type `type_url`&quot;&#125;, &#125;, &#125; reply := &amp;pb.TestResponse&#123; Msg: &quot;ok 200&quot;, Name: req.GetName() + &quot;:&quot; + strconv.FormatInt(int64(req.Extensions[0].Id), 10), Extensions: extension, &#125; return reply, nil&#125;func (t *TestService) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) &#123; return &amp;empty.Empty&#123;&#125;, nil&#125; 实现gRPC客户端client/client.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package mainimport ( &quot;context&quot; &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;flag&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;time&quot; &quot;github.com/golang/protobuf/ptypes/empty&quot; &quot;github.com/golang/protobuf/ptypes/timestamp&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/protobuf/types/known/anypb&quot;)var ( address = flag.String(&quot;addr&quot;, &quot;localhost:8888&quot;, &quot;addr&quot;) name = flag.String(&quot;name&quot;, &quot;world&quot;, &quot;name&quot;))func main() &#123; flag.Parse() cert, err := tls.LoadX509KeyPair(&quot;cert/client.pem&quot;, &quot;cert/client.key&quot;) if err != nil &#123; log.Fatalf(&quot;load cert files failed,err:%v&quot;, err) &#125; certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;cert/ca.pem&quot;) if err != nil &#123; log.Fatalf(&quot;read ca file failed,err:%v&quot;, err) &#125; if ok := certPool.AppendCertsFromPEM(ca); !ok &#123; log.Fatal(&quot;failed to append ca certs&quot;) &#125; creds := credentials.NewTLS(&amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, // 客户端证书 ServerName: &quot;localhost&quot;, RootCAs: certPool, &#125;) //conn, err := grpc.Dial(*address, grpc.WithInsecure()) conn, err := grpc.Dial(*address, grpc.WithTransportCredentials(creds)) if err != nil &#123; log.Fatalf(&quot;failed to connect server,err:%v&quot;, err) &#125; defer conn.Close() // hello client helloClient := pb.NewHelloServiceClient(conn) sayHello(helloClient) // user client userClient := pb.NewUserServiceClient(conn) login(userClient) loginStreaming(userClient) // test client testClient := pb.NewTestServiceClient(conn) test(testClient) ping(testClient)&#125;func sayHello(client pb.HelloServiceClient) &#123; reply, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatal(err) &#125; log.Println(reply.GetMessage()) stream, err := client.Streaming(context.Background()) if err != nil &#123; log.Fatalf(&quot;failed to call:%v&quot;, err) &#125; go func() &#123; for &#123; err := stream.Send(&amp;pb.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatalf(&quot;failed to send,err:%v&quot;, err) break &#125; time.Sleep(time.Second) &#125; &#125;() for &#123; reply, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; break &#125; log.Fatalf(&quot;failed to recv,err:%v&quot;, err) break &#125; log.Println(reply.GetMessage()) &#125;&#125;func login(client pb.UserServiceClient) &#123; var userEmail = map[string]string&#123;&quot;email&quot;: &quot;test@qq.com&quot;&#125; var userWeight = map[string]int32&#123;&quot;weight&quot;: 170&#125; var userNum = map[string]*pb.UserLoginRequest_PhoneNumber&#123; &quot;001&quot;: &#123;PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &quot;002&quot;: &#123;PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &quot;003&quot;: &#123;PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var phones = []*pb.UserLoginRequest_PhoneNumber&#123; &#123;PhoneNumber: &quot;1111111&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &#123;PhoneNumber: &quot;2222222&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &#123;PhoneNumber: &quot;3333333&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var lastUpdateDate = &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix(), Nanos: int32(999999999), &#125; request := &amp;pb.UserLoginRequest&#123; UserId: int64(100), UserName: &quot;aaaaa&quot;, UserNickname: &quot;用户昵称&quot;, UserCountry: &quot;china&quot;, UserGender: 1, UserCredits: 111.111, IsAdmin: true, AuthCode: []byte(&quot;abcdefg&quot;), UserBalance: 10000000.0000, UserHobby: pb.UserLoginRequest_music, LuckyNumbers: []int32&#123;2, 4, 6, 8, 10&#125;, UserEmail: userEmail, UserWeight: userWeight, UserNum: userNum, LoginStatus: pb.LoginStatus_success, Phones: phones, LastUpdateDate: lastUpdateDate, &#125; resp, err := client.Login(context.Background(), request) if err != nil &#123; log.Fatal(err) &#125; log.Println(resp)&#125;func loginStreaming(client pb.UserServiceClient) &#123; var userEmail = map[string]string&#123;&quot;email&quot;: &quot;test123@qq.com&quot;&#125; var userWeight = map[string]int32&#123;&quot;weight&quot;: 180&#125; var userNum = map[string]*pb.UserLoginRequest_PhoneNumber&#123; &quot;test001&quot;: &#123;PhoneNumber: &quot;001&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &quot;test002&quot;: &#123;PhoneNumber: &quot;002&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &quot;test003&quot;: &#123;PhoneNumber: &quot;003&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var phones = []*pb.UserLoginRequest_PhoneNumber&#123; &#123;PhoneNumber: &quot;test-1111111&quot;, PhoneType: pb.UserLoginRequest_mobile&#125;, &#123;PhoneNumber: &quot;test-2222222&quot;, PhoneType: pb.UserLoginRequest_home&#125;, &#123;PhoneNumber: &quot;test-3333333&quot;, PhoneType: pb.UserLoginRequest_work&#125;, &#125; var lastUpdateDate = &amp;timestamp.Timestamp&#123; Seconds: time.Now().Unix(), Nanos: int32(999999999), &#125; login := &amp;pb.UserLoginRequest&#123; UserId: int64(101), UserName: &quot;bbbbbbb&quot;, UserNickname: &quot;用户昵称&quot;, UserCountry: &quot;china&quot;, UserGender: 2, UserCredits: 222.222, IsAdmin: true, AuthCode: []byte(&quot;xxxxx&quot;), UserBalance: 20000000.0000, UserHobby: pb.UserLoginRequest_tour, LuckyNumbers: []int32&#123;34, 55, 333, 33, 199&#125;, UserEmail: userEmail, UserWeight: userWeight, UserNum: userNum, LoginStatus: pb.LoginStatus_error, Phones: phones, LastUpdateDate: lastUpdateDate, &#125; stream, err := client.LoginStreaming(context.Background()) if err != nil &#123; log.Fatalf(&quot;failed to call:%v&quot;, err) &#125; go func() &#123; for &#123; err := stream.Send(login) if err != nil &#123; log.Fatalf(&quot;failed to send,err:%v&quot;, err) break &#125; time.Sleep(time.Second) &#125; &#125;() for &#123; reply, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; break &#125; log.Printf(&quot;failed to recv,err:%v&quot;, err) break &#125; log.Println(reply) &#125;&#125;func test(client pb.TestServiceClient) &#123; req := &amp;pb.TestRequest&#123; Name: &quot;test&quot;, Extensions: []*pb.Extension&#123; &amp;pb.Extension&#123;Id: 8888, Data: nil&#125;, &amp;pb.Extension&#123;Id: 9999, Data: &amp;anypb.Any&#123;TypeUrl: &quot;type url&quot;&#125;&#125;, &#125;, &#125; reply, err := client.Test(context.Background(), req) if err != nil &#123; log.Fatal(err) &#125; log.Println(reply)&#125;func ping(client pb.TestServiceClient) &#123; reply, err := client.Ping(context.Background(), &amp;empty.Empty&#123;&#125;) if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;%v&quot;, reply)&#125; gRPC服务端server/server.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;flag&quot; &quot;tests/grpc/services&quot; pb &quot;tests/grpc/services/pb&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot;)var ( serverPort = flag.String(&quot;port&quot;, &quot;:8888&quot;, &quot;port&quot;))func main() &#123; flag.Parse() cert, err := tls.LoadX509KeyPair(&quot;cert/server.pem&quot;, &quot;cert/server.key&quot;) if err != nil &#123; log.Fatalf(&quot;load cert files failed,err:%v&quot;, err) &#125; certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;cert/ca.pem&quot;) if err != nil &#123; log.Fatalf(&quot;read ca file failed,err:%v&quot;, err) &#125; if ok := certPool.AppendCertsFromPEM(ca); !ok &#123; log.Fatal(&quot;failed to append certs&quot;) &#125; creds := credentials.NewTLS(&amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, // 服务端证书 ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: certPool, &#125;) server := grpc.NewServer(grpc.Creds(creds)) pb.RegisterHelloServiceServer(server, new(services.HelloService)) pb.RegisterUserServiceServer(server, new(services.UserService)) pb.RegisterTestServiceServer(server, new(services.TestService)) l, err := net.Listen(&quot;tcp&quot;, *serverPort) if err != nil &#123; log.Fatalf(&quot;failed to listen,err:%v&quot;, err) &#125; log.Printf(&quot;server start at [%s]&quot;, *serverPort) err = server.Serve(l) if err != nil &#123; log.Fatal(err) &#125;&#125; gRPC使用实例查看目录结构： 1cd tests 查看目录层级： 1tree -L 1 1234567└── grpc ├── client ├── proto ├── server └── services5 directories, 0 files 1234567891011121314151617181920212223242526272829└── grpc ├── client │ ├── cert │ │ ├── ca.pem │ │ ├── client.key │ │ └── client.pem │ └── client.go ├── proto │ ├── common.proto │ ├── generate.sh │ ├── hello.proto │ └── user.proto ├── server │ ├── auth_server.go │ ├── cert │ │ ├── ca.pem │ │ ├── server.key │ │ └── server.pem │ └── server.go └── services ├── hello.go ├── pb │ ├── common.pb.go │ ├── hello.pb.go │ └── user.pb.go ├── test.go └── user.go8 directories, 19 files","categories":[{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"}]},{"title":"Linux进程维护shell脚本","slug":"linux/linux-process-start","date":"2021-11-29T06:30:28.000Z","updated":"2021-11-29T06:45:36.000Z","comments":true,"path":"2021/11/29/linux/linux-process-start/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/linux/linux-process-start/","excerpt":"","text":"start.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bashprocess_name=`pwd | xargs basename`usage() &#123; echo &quot;./start.sh [ start | stop | reload | status ]&quot;&#125;status() &#123; ps -ef | grep $process_name | grep -v grep&#125;start() &#123; echo &quot;start $process_name....&quot; nohup ./$process_name 2&gt;&amp;1 1&gt;/dev/null &amp; status&#125;stop() &#123; echo &quot;stop $process_name...&quot; ps -ef | grep $process_name | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; |xargs kill -9 status&#125;reload() &#123; echo &quot;reload $process_name...&quot; ps -ef | grep $process_name |grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; |xargs kill -HUP status&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; reload) reload ;; status) status ;; *) usage ;;esac","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux使用tar压缩时排除某个目录或文件","slug":"linux/linux-tar-exclude","date":"2021-11-29T06:30:28.000Z","updated":"2021-12-02T02:14:13.000Z","comments":true,"path":"2021/11/29/linux/linux-tar-exclude/","link":"","permalink":"https://hqd8080.github.io/2021/11/29/linux/linux-tar-exclude/","excerpt":"","text":"例如：在/home/abc/目录下有4个子目录：abc01、abc02、abc03、abc04，现在想把/home/abc/目录下的abc01、abc02、abc03打包成abc.tar.gz，不打包abc04！ 操作如下： cd /home 1tar -zcvf abc.tar.gz --exclude=abc04 ./abc 打包成功，可以在/home目录下面看到abc.tar.gz文件了","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux服务器备份数据库shell脚本","slug":"linux/linux-db-backup","date":"2021-11-16T09:42:28.000Z","updated":"2021-11-25T03:09:51.000Z","comments":true,"path":"2021/11/16/linux/linux-db-backup/","link":"","permalink":"https://hqd8080.github.io/2021/11/16/linux/linux-db-backup/","excerpt":"","text":"data_backup.sh 123456789101112131415161718192021222324252627282930313233343536#!/bin/bashDIR=&quot;/usr/local/data/data_backup&quot;DATE=date +%Y%m%d%H%M%SDATE_DAY=date +%Y%m%decho $DATEDB_HOST=&quot;127.0.0.1&quot;DB_USER=&quot;root&quot;DB_PASS=&quot;dbpwd&quot;mkdir $&#123;DIR&#125;/$&#123;DATE_DAY&#125;cd $&#123;DIR&#125;/$&#123;DATE_DAY&#125;/usr/local/mysql/bin/mysqldump -h$&#123;DB_HOST&#125; -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --databases dbname &gt;dbname-$&#123;DATE&#125;.sqlif [ $? -eq 0 ]thentar -zcf mydatabase-$&#123;DATE&#125;.sql.tgz dbname-$&#123;DATE&#125;.sqlelsesleep 20/usr/local/mysql/bin/mysqldump -h$&#123;DB_HOST&#125; -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; --databases dbname &gt;dbname-$&#123;DATE&#125;.sqlif [ $? -eq 0 ];thentar -zcf mydatabase-$&#123;DATE&#125;.sql.tgz dbname-$&#123;DATE&#125;.sqlfirm -rf dbname-$&#123;DATE&#125;.sql#find $DIR -type d -mtime +30 |xargs rm -rfDATE_STR=date +%Y%m%d%H%M%Secho $DATE &gt;&gt;$&#123;DIR&#125;/$&#123;DATE_DAY&#125;/mysql_dump$DATE_DAY.logecho $DATE_STR &gt;&gt;$&#123;DIR&#125;/$&#123;DATE_DAY&#125;/mysql_dump$DATE_DAY.log 12#设置脚本data_backup.sh有可执行的权限chmod +x ./data_backup.sh 12345crontab -e #添加计划任务0 23 * * * /usr/local/data/data_backup.shsystemctl start crond.service #设置cron开机启动 解决：mysqldump: [Warning] Using a password on the command line interface can be insecure.1234567vim /etc/my.cnf[mysqldump]host=127.0.0.1user=rootpassword=123456port=3306 修改完配置文件后,只需要执行mysqldump脚本就可以了;备份脚本中不需要涉及用户名密码相关信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"},{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux计划任务Crontab实例详解","slug":"linux/linux-crontab","date":"2021-11-15T01:40:28.000Z","updated":"2021-12-02T09:01:57.000Z","comments":true,"path":"2021/11/15/linux/linux-crontab/","link":"","permalink":"https://hqd8080.github.io/2021/11/15/linux/linux-crontab/","excerpt":"","text":"crontab是一个用于设置周期性被执行任务的工具，类似于Windows系统中的任务计划程序。 安装并检查crontab服务 检查crond工具是不是安装：crontab -l #任务列表 检查crond服务是否启动：service crond status #查看crontab状态 安装crontab yum install vixie-cron #安装 chkconfig crond on #设为开机启动，先要安装chkconfig（yum install chkconfig） service crond start #启动 service crond stop #停止 /etc/rc.d/init.d/crond restart #重启 /etc/rc.d/init.d/crond reload #不中断服务，重新载入配置 设置任务计划 /home/test.sh #要自动执行的脚本程序路径 chmod +x /home/test.sh #对脚本文件添加执行权限，否则不能执行 crontab -e #编辑配置文件，在最后一行添加内容 30 1 * * * root /home/test.sh #表示每天凌晨1点30分执行脚本 :wq! #保存退出 crontab文件的格式minute hour day month weekday username command minute：分，值为0-59 hour：小时，值为1-23 day：天，值为1-31 month：月，值为1-12 weekday：星期，值为0-6（0代表星期天，1代表星期一，以此类推） username：要执行程序的用户，一般设置为root command：要执行的程序路径（设置为绝对路径）例如：/home/test.sh crontab实例 每晚的21：30重启apache 130 21 * * * service httpd restart 每月的1，10，22日的4：45重启apache 145 4 1，10，22，* * service httpd restart 每月的1到10日的4：45重启apache 145 4 1-10 * * service httpd restart 每隔两分钟重启apache服务器 12*/2 * * * * service httpd restart1-59/2 * * * * service httpd restart 晚上11点到早上7点之间，每隔一小时重启apache 10 23-7/1 * * * service httpd restart 每天18：00至23：00之间每隔30分钟重启apache 120，30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每周一到周五的11:41开始，每隔10分钟执行一次 12341,51 11 * * 1-5 root /home/test.sh1-59/10 12-23 * * 1-5 root /home/test.sh 在每天的10:31开始，每隔2小时重复一次 131 10-23/2 * * * root /home/test.sh 每天的10:30开始，每隔2小时重复一次 130 10-23/2 * * * root /home/test.sh 每周一到周五9:30 130 9 * * 1-5 root /home/test.sh 每周一到周五8:00，每周一到周五9:00 10 8,9 * * 1-5 root /home/test.sh 每周一到周五9:25到11:35之间、13:00到15:00之间，每隔10分钟运行一次 123456725,35,45,55 9 * * 1-5 root /home/test.sh5-59/10 10 * * 1-5 root /home/test.sh5,15,25,35 11 * * 1-5 root /home/test.sh*/10 13-15 * * 1-5 root /home/test.sh 每周一到周五8:30、8:50、9:30、10:00、10:30、11:00、11:30、13:30、14:00、14:30、5:00分别执行一次 12345678930,50 8 * * 1-5 root /home/test.sh30 9 * * 1-5 root /home/test.sh*/30 10-11 * * 1-5 root /home/test.sh30 13 * * 1-5 root /home/test.sh0,30 14-15 * * 1-5 root /home/test.sh 1`crontab -e -u root` #为某个用户添加计划任务 crontab中最小只能设置到每分钟执行一个命令，如果想每半分钟执行某个命令，可以通过shell脚本的sleep命令配合crontab即可完成这一功能 1*/1 * * * * sleep 30s； echo &quot;this is a test!!&quot; 小结: *，表示任何时候都匹配 可以用&ldquo;A，B，C&rdquo;表示A或者B或者C时执行命令 可以用&ldquo;A-B&rdquo;表示A到B之间时执行命令 可以用&ldquo;*/A&rdquo;表示每A分钟（小时等）执行一次命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"Linux使用cp命令直接覆盖不提示的方法","slug":"linux/linux-cp","date":"2021-11-15T01:30:28.000Z","updated":"2021-12-02T02:19:55.000Z","comments":true,"path":"2021/11/15/linux/linux-cp/","link":"","permalink":"https://hqd8080.github.io/2021/11/15/linux/linux-cp/","excerpt":"","text":"普通的cp命令使用例如：cp abc.txt /home 如果/home里面之前有abc.txt文件，会提示你是否要覆盖？这个时候你需要输入Y，假如文件很多的话，每复制一个文件都要输入一次Y。 下面介绍cp文件时直接覆盖不提示的方法命令如下： \\cp abc.txt /home 直接复制abc.txt 到/home里面，不管/home里面之前是否有这个文件都会直接覆盖，不再出现覆盖提示！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"}]},{"title":"go-zero工具goctl生成api、rpc代码","slug":"go-zero/gozero003","date":"2021-03-30T12:10:10.000Z","updated":"2022-11-21T07:15:23.085Z","comments":true,"path":"2021/03/30/go-zero/gozero003/","link":"","permalink":"https://hqd8080.github.io/2021/03/30/go-zero/gozero003/","excerpt":"","text":"go-zero工具goctl生成api、rpc代码go-zero常用代码生成脚本 12345cat ~/.bash_profilealias apigen=&quot;goctl api go -api *.api -dir ../ --style=goZero&quot;alias rpcgen=&quot;goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero&quot; 生成单个proto文件代码 1protoc -I./ --go_out = paths = source_relative:.--go -grpc_out = paths = source_relative:.common.proto","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"以太坊代币协议标准ERC-20与ERC-223的区别","slug":"blockchain/blockchain-eth-erc","date":"2021-03-29T12:10:10.000Z","updated":"2022-11-19T08:13:19.417Z","comments":true,"path":"2021/03/29/blockchain/blockchain-eth-erc/","link":"","permalink":"https://hqd8080.github.io/2021/03/29/blockchain/blockchain-eth-erc/","excerpt":"","text":"ERC-20标准ERC-20标准是在2015年11月份推出的，使用这种规则的代币，表现出一种通用的和可预测的方式。简单地说，任何 ERC-20 代币都能立即兼容以太坊钱包（几乎所有支持以太币的钱包，包括Jaxx、MEW、imToken等，也支持 erc-20的代币），由于交易所已经知道这些代币是如何操作的，它们可以很容易地整合这些代币。这就意味着，在很多情况下，这些代币都是可以立即进行交易的。 ERC-20代币标准【官方文档】：https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md ERC-20是各个代币的标准接口，ERC-20代币仅仅是以太坊代币的子集。为了充分兼容ERC-20，开发者需要将一组特定的函数（接口）集成到他们的智能合约中，以便在高层面能够执行以下操作： 获得代币总供应量 获得账户余额 转让代币 批准花费代币 ERC-20让以太坊区块链上的其他智能合约和去中心化应用之间无缝交互。一些具有部分但非所有ERC20标准功能的代币被认为是部分ERC-20兼容，这还要视其具体缺失的功能而定，但总体是它们仍然很容易与外部交互。 ERC-20标准存在的问题ERC-20标准无法通过接收方合同处理传入的交易，这是该令牌存在的最大问题，也是开发者一直希望改进的地方。ERC-20令牌无法将令牌发送给一个与这些令牌不兼容的契约，也正因为这样，部分资金存在丢失的风险。Reddit上的一篇文章指出，由于被发送到“错误”的合同上，大约价值40万美元的ERC-20令牌被困，这对整个以太坊生态系统而言是一个巨大的威胁。 场景：将令牌直接发送给令牌的智能合同将导致资金损失，这是因为一个令牌的合同只会跟踪和分配资金。例如，当您从钱包中向另一个用户发送令牌时，该钱包将调用令牌的合约来更新数据库，所以如果您试图将令牌直接传输到令牌的合约中，那么由于该令牌的合约无法响应，所以金钱就“丢失”了。 ERC-223要解决的首要问题自从引入ERC-20令牌标准以来，几乎所有的基于以太坊的令牌都成功的接受了这个新标准。然而其自身的缺点需要及时解决，这便是ERC-223令牌诞生的原因。ERC-223令牌标准将向现有的ERC-20标准引入一个新功能，以防止意外转移的发生。 ERC-223标准ERC-223允许用户通过一个函数transfer调用，将令牌发送到合约或电子钱包地址，而不需要针对钱包交易或合约交易做不同的处理如果接收者是钱包，则ERC-223令牌传输将与ERC-20传输相同。如果接收方是合约，ERC-223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。 tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将bytes _data附加到类似于连接到Ether事务的_data的令牌事务。 它将通过令牌合约，并将通过接收方合同的tokenFallback函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC-20 ABI。 在这种情况下_data将为空字节数组。 ERC-223定义的接口totalSupply – 获取总量 1function totalSupply() constant returns (uint256 totalSupply) name – 得到token的名字 1function name() constant returns (string _name) symbol – 得到token的符号 1function symbol() constant returns (bytes32 _symbol) decimals – 得到token的小数点后几位 1function decimals() constant returns (uint8 _decimals) balanceOf – 得到地址是_owner的账户的余额 1function balanceOf(address _owner) constant returns (uint256 balance) transfer(address, uint) – 转移令牌 123function transfer(address _to, uint _value) returns (bool)function transfer(address _to, uint _value, bytes _data) returns (bool) 由于向后兼容性原因，因为ERC20传输函数没有字节参数。1、如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。2、如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。3、如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。4、_data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。 注意：检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。 事件Transfer – 当token转移的时候触发，合约和token一起工作 1event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data) tokenFallback – 令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能 1function tokenFallback(address _from, uint _value, bytes _data) _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。 注意：msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）在_from thetokenFallback函数内。 重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。 示例代码ERC223_Interface.sol 123456789101112131415161718pragma solidity ^0.4.9; /* 新的 ERC23 contract 接口文件 */contract ERC223 &#123; uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);&#125; Receiver_Interface.sol 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.9; /* * Contract that is working with ERC223 tokens */ contract ContractReceiver &#123; struct TKN &#123; address sender; //调用合约的人 uint value; bytes data; bytes4 sig; //签名 &#125; function tokenFallback(address _from, uint _value, bytes _data)&#123; TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) &lt;&lt; 8) + (uint32(_data[1]) &lt;&lt; 16) + (uint32(_data[0]) &lt;&lt; 24); tkn.sig = bytes4(u); /* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */ &#125;&#125; ERC223_Token.sol 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141pragma solidity ^0.4.9;import &quot;./Receiver_Interface.sol&quot;;import &quot;./ERC223_Interface.sol&quot;; /** * ERC23 token by Dexaran * * https://github.com/Dexaran/ERC23-tokens * https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */contract SafeMath &#123; uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (x &gt; MAX_UINT256 - y) throw; return x + y; &#125; function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (x &lt; y) throw; return x - y; &#125; function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) &#123; if (y == 0) return 0; if (x &gt; MAX_UINT256 / y) throw; return x * y; &#125;&#125;//示例的智能合约代码contract ERC223Token is ERC223, SafeMath &#123; mapping(address =&gt; uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // 获取token的名称 function name() constant returns (string _name) &#123; return name; &#125; // 获取token的符号 function symbol() constant returns (string _symbol) &#123; return symbol; &#125; // 获取token精确到小数点后的位数 function decimals() constant returns (uint8 _decimals) &#123; return decimals; &#125; // 获取token的发布总量 function totalSupply() constant returns (uint256 _totalSupply) &#123; return totalSupply; &#125; // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) &#123; //如果to是合约 if(isContract(_to)) &#123; if (balanceOf(msg.sender) &lt; _value) throw; //如果当前的余额不够就抛出 balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);//发送者的余额做减法 balances[_to] = safeAdd(balanceOf(_to), _value); //接收者的余额做加法 ContractReceiver receiver = ContractReceiver(_to); //初始化接收合约，构造函数参数为接收者的合约地址 receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; &#125; else &#123; return transferToAddress(_to, _value, _data); &#125;&#125; // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data) returns (bool success) &#123; if(isContract(_to)) &#123; return transferToContract(_to, _value, _data); &#125; else &#123; return transferToAddress(_to, _value, _data); &#125;&#125; // 类似于ERC20传输的标准功能传输，没有_data。 // 由于向后兼容性原因而增加。 function transfer(address _to, uint _value) returns (bool success) &#123; //类似于没有_data的ERC20传输的标准功能传输 //由于向后兼容性原因而增加 bytes memory empty; if(isContract(_to)) &#123;//如果是合约 return transferToContract(_to, _value, empty); &#125; else &#123; return transferToAddress(_to, _value, empty); &#125;&#125; //组装定地址字节码。 如果存在字节码，那么_addr是一个合约。 function isContract(address _addr) private returns (bool is_contract) &#123; uint length; assembly &#123; //检索目标地址上的代码大小，这需要汇编 length := extcodesize(_addr) &#125; return (length&gt;0); &#125; //当传递目标是一个地址时调用函数 function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) &#123; if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; &#125; //当传递目标是一个合约时调用函数 function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) &#123; if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); //必须要调用这个回调 Transfer(msg.sender, _to, _value, _data); return true;&#125; //得到_owner的余额 function balanceOf(address _owner) constant returns (uint balance) &#123; return balances[_owner]; &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"blockchain","slug":"blockchain","permalink":"https://hqd8080.github.io/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://hqd8080.github.io/tags/ethereum/"},{"name":"solidity","slug":"solidity","permalink":"https://hqd8080.github.io/tags/solidity/"}]},{"title":"go-zero代码生成工具goctl的使用","slug":"go-zero/gozero002","date":"2021-03-29T02:10:10.000Z","updated":"2022-11-08T15:27:57.082Z","comments":true,"path":"2021/03/29/go-zero/gozero002/","link":"","permalink":"https://hqd8080.github.io/2021/03/29/go-zero/gozero002/","excerpt":"","text":"go-zero代码生成工具goctl的使用go-zero生成API代码命令12345678910mkdir gozero_demo &amp;&amp; cd gozero_demomkdir -p user-api/api cd user-api/api// 创建user.api定义文件touch user.api 1234567891011121314151617181920212223syntax = &quot;v1&quot;info( author: &quot;hqd8080&quot; date: &quot;2022-09-27&quot; desc: &quot;api 语法示例及语法说明&quot;)type ( UserInfoReq &#123; UserId int64 `json:&quot;userId&quot;` &#125; UserInfoResp &#123; UserId int64 `json:&quot;userId&quot;` Nickname string `json:&quot;nickname&quot;` &#125;)service user-api&#123; @doc &quot;获取用户信息&quot; @handler userInfo post /user/info (UserInfoReq) returns (UserInfoResp)&#125; 12// 在当前目录下执行goctl api go -api *.api -dir ../ --style=gozero go-zero生成RPC代码命令1234567891011121314151617181920在项目根路径创建user-rpc目录，在目录里面创建pb文件夹，在pb文件夹里面创建user.proto文件syntax = &quot;proto3&quot;;option go_package = &quot;./pb&quot;;package pb;message GetUserInfoReq &#123; int64 id = 1;&#125;message GetUserInfoResp &#123; int64 id = 1; string nickname = 2;&#125;service usercenter &#123; rpc GetUserInfo(GetUserInfoReq) returns (GetUserInfoResp);&#125; 12在当前目录执行goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero go-zero生成model文件命令123goctl model mysql datasource -url=&quot;$&#123;username&#125;:$&#123;passwd&#125;@tcp($&#123;host&#125;:$&#123;port&#125;)/$&#123;dbname&#125;&quot; -table=&quot;$&#123;tables&#125;&quot; -dir=&quot;$&#123;modeldir&#125;&quot; -cache=true --style=goZerogoctl model mysql datasource -url=root:12345678@tcp(127.0.0.1:3306)/zerodemo -table=user -dir=./model -cache=true --style=goZero go-zero生成dockerfile文件1goctl docker -go user.go go-zero生成k8s部署文件1goctl kube deploy -name user-api -namespace go-zero -image user-api:v1.0 -o user-api.yaml -port 1001 -nodePort 31001","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"MySQL5.7版本sql_mode=only_full_group_by问题解决","slug":"MySQL/mysql-only-full-group-by","date":"2021-03-28T02:10:10.000Z","updated":"2022-11-19T08:11:51.986Z","comments":true,"path":"2021/03/28/MySQL/mysql-only-full-group-by/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/MySQL/mysql-only-full-group-by/","excerpt":"","text":"MySQL5.7版本sql_mode=only_full_group_by问题 MySQL5.7.x版本，默认是开启了only_full_group_by模式的，但开启这个模式后，原先的group by语句就报错，然后又把它移除了 一旦开启only_full_group_by，感觉group by将变成和distinct一样，只能获取受到其影响的字段信息，无法和其他未受其影响的字段共存，这样group by的功能将变得十分狭窄了 only_full_group_by 模式开启比较好 因为在 mysql 中有一个函数：any_value(field) 允许，非分组字段的出现（和关闭only_full_group_by模式有相同效果） 具体出错提示： 1[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &#x27;information_schema.PROFILING.SEQ&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 1、查看sql_mode 1select @@global.sql_mode; 查询出来的值为： 1ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION; 2、去掉ONLY_FULL_GROUP_BY，重新设置值 1set @@global.sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; 3、上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行： 1set sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; 解决办法大致有两种： 1：在sql查询语句中不需要group by的字段上使用any_value()函数 这种对于已经开发了不少功能的项目不太合适，毕竟要把原来的sql都给修改一遍 2：修改my.cnf（windows下是my.ini）配置文件，删掉only_full_group_by这一项 若我们项目的mysql安装在ubuntu上面，找到这个文件打开一看，里面并没有sql_mode这一配置项，想删都没得删。 当然，还有别的办法，打开mysql命令行，执行命令 1select @@sql_mode; 这样就可以查出sql_mode的值，复制这个值，在my.cnf中添加配置项（把查询到的值删掉only_full_group_by这个选项，其他的都复制过去） 1sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION; 如果[mysqld]这行被注释掉的话记得要打开注释，然后重重启mysql服务 注：使用命令 1set sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 这样可以修改一个会话中的配置项，在其他会话中是不生效的","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"}]},{"title":"以太坊私网开发环境搭建","slug":"blockchain/blockchain-eth-develop","date":"2021-03-28T02:10:10.000Z","updated":"2022-11-19T08:13:19.421Z","comments":true,"path":"2021/03/28/blockchain/blockchain-eth-develop/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/blockchain/blockchain-eth-develop/","excerpt":"","text":"智能合约：就是运行在以太坊这个”全球计算机”上的”进程”，之所以有上述比喻，是因为以太坊网络的节点遍布全球，在这样的网络中运行计算就相当于在”一台全球计算机”中运行计算 智能：智能合约是可以自动运行的 合约：以太坊的合约代码多会涉及一些资产转移，而现实世界中签订合同也多是伴随着资产转移，因此把这样的代码叫合约 Linux安装Geth（go-ethereum）官网：https://geth.ethereum.org/docs/install-and-build/installing-geth 1、以命令行的方式安装12345sudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install ethereum 输入geth --help验证安装 2、以压缩包的方式安装 第一步：下载安装包 1wget https://gethstore.blob.core.windows.net/builds/geth-alltools-linux-amd64-1.9.10-58cf5686.tar.gz` 第二步：解压 1tar zxvf geth-alltools-linux-amd64-1.9.10-58cf5686.tar.gz geth-alltools-linux-amd64-1.9.10-58cf5686/` 第三步：配置（临时）环境变量 1234mv geth-alltools-linux-amd64-1.9.10-58cf5686 ~/geth-home`export PATH=$HOME/geth-home:$PATHecho export PATH=$HOME/geth-home:$PATH &gt;&gt; ~/.bashrc注：root用户执行后，将geth-alltools-linux-amd64-1.9.10-58cf5686移动并重命名到了/root/geth-home位置 第四步：输入geth version或geth --help验证安装 搭建私网并启动Geth主网：以太坊真实节点运行的网络，节点遍布全球，此网络中使用的ETH是真实的虚拟数字货币，部署合约时需要消耗真金白银 测试网：测试网的节点没有主网节点那么多，主要是为以太坊开发者提供一个测试的平台环境，此网络上的ETH可以通过做任务获得 私网：私网是由开发者自行组建的网络，不与主网及测试网连通，独立存在，仅用于个人测试或企业项目使用 不论是主网、测试网还是私网，都可以使用Geth来启动，Geth默认连接的是以太网主网，如果想要连接测试网可以连接Ropsten或rinkeby 12345# Ropsten测试网络geth --testnet --fast --cache=512 console# Rinkeby测试网络geth --rinkeby --fast --cache=512 console 1、下载工程文件1git clone https://github.com/hqd8080/eth-develop 2、进入目录进行初始化12345cd eth-developmkdir datageth init genesis.json --datadir ./data 3、执行脚本，启动Geth节点1./geth_run.sh 4、genesis.json内容123456789101112131415161718&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 18, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;, &quot;alloc&quot; : &#123;&#125;, &quot;coinbase&quot; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x2&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; : &quot;0xffffffff&quot;, &quot;nonce&quot; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot;&#125; 5、geth_run.sh内容1234#!/bin/bashgeth --datadir ./data \\--networkid 18 --http --http.addr 0.0.0.0 --http.vhosts &quot;*&quot; --http.api &quot;db,net,eth,web3,personal,debug&quot; --http.corsdomain &quot;*&quot; \\--snapshot --allow-insecure-unlock console 2&gt;&gt; geth.log","categories":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"blockchain","slug":"blockchain","permalink":"https://hqd8080.github.io/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://hqd8080.github.io/tags/ethereum/"}]},{"title":"微服务框架go-zero学习笔记","slug":"go-zero/gozero001","date":"2021-03-28T02:10:10.000Z","updated":"2022-09-27T05:56:18.056Z","comments":true,"path":"2021/03/28/go-zero/gozero001/","link":"","permalink":"https://hqd8080.github.io/2021/03/28/go-zero/gozero001/","excerpt":"","text":"Go语言微服务框架go-zero学习笔记使用 go-zero 的好处： 轻松获得支撑千万日活服务的稳定性 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码 微服务治理中间件可无缝集成到其它现有框架使用 极简的 API 描述，一键生成各端代码 自动校验客户端请求参数合法性 大量微服务治理和并发工具包 go-zero 框架设计思考： 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 go-zero 项目实现和特点： go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 项目架构图 开发环境安装安装goctl工具12// Go 1.16 及以后版本GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/go-zero/tools/goctl@latest 设置环境变量123456789101112sudo vim ~/.bash_profile# golangexport GOROOT=/usr/local/goexport GOPATH=/Users/hqd/goexport GOPROXY=https://goproxy.cn,directexport GOSUMDB=sum.golang.google.cnexport GO111MODULE=onexport GOPRIVATE=*gitee.comexport PATH=$GOROOT/bin:$GOPATH/bin:$PATHsource ~/.bash_profile 查看版本goctl -v 安装protobuf工具、protoc-gen-go、protoc-gen-go-grpc去github官网下载相应版本最新版本到本地解压拿到可执行文件protoc https://github.com/protocolbuffers/protobuf/releases 123sudo mv protoc /usr/local/binsudo chmod +x /usr/local/bin/protoc 123protoc --versionlibprotoc 3.20.2 12345678protoc &gt;= 3.13.0 如果没安装请先安装 https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中protoc-gen-go 如果没有安装请先安装 go install google.golang.org/protobuf/cmd/protoc-gen-go@latestprotoc-gen-go-grpc如果没有安装请先安装 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest","categories":[{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"}]},{"title":"Go语言协程泄漏","slug":"golang/go-leakage","date":"2020-06-04T12:40:28.000Z","updated":"2022-11-19T08:07:54.452Z","comments":true,"path":"2020/06/04/golang/go-leakage/","link":"","permalink":"https://hqd8080.github.io/2020/06/04/golang/go-leakage/","excerpt":"","text":"Go语言协程泄漏协程泄漏是指由于某种原因，在协程执行后并未正确结束；而是处于阻塞状态。那么此时垃圾回收机制也无法回收这些协程占用的资源；这就导致无法释放的协程数量越来越多，于是发生泄漏 发生协程泄露的场景协程发生泄漏一般是通道chan使用不当；或者锁同步机制使用错误所导致；通道发送不接收；接收不发送；都会导致协程泄漏","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"WebSocket协议","slug":"golang/websocket","date":"2020-06-04T12:40:28.000Z","updated":"2022-11-19T08:07:54.448Z","comments":true,"path":"2020/06/04/golang/websocket/","link":"","permalink":"https://hqd8080.github.io/2020/06/04/golang/websocket/","excerpt":"","text":"WebSocket协议原理在WebSocket中，客户端（浏览器）和服务器只需要完成一次握手，在二者之间就能创建持久性的连接（长连接），而后进行双向的数据传输。WebSocket能更好的节省服务器资源和带宽，并且能够更实时的进行通信。一旦建立WebSocket连接，无论是服务器还是客户端，任意一方都可以直接向对方发送数据。 客户端为了和服务端建立一个WebSocket连接，首先要向服务器发起一个HTTP请求，这个请求和普通的请求不一样；会包含一些附加头信息，比如：Upgrade：WebSocket，服务器会解析这些附加头信息。WebSocket协议为了兼容现有浏览器，所以在握手阶段使用了HTTP协议；WebSocket是类似TCP长连接的通信模式；WebSocket协议建立在TCP协议之上","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"webSocket","slug":"webSocket","permalink":"https://hqd8080.github.io/tags/webSocket/"}]},{"title":"Goland文件自动注释配置","slug":"golang/go-goland-setting","date":"2020-06-03T06:22:50.000Z","updated":"2022-11-19T08:07:54.460Z","comments":true,"path":"2020/06/03/golang/go-goland-setting/","link":"","permalink":"https://hqd8080.github.io/2020/06/03/golang/go-goland-setting/","excerpt":"","text":"File / Setting / Editor / File and Template 123456789/** * @Author: $&#123;USER&#125; * @Description: * @File: $&#123;NAME&#125; * @Version: 1.0.0 * @Date: $&#123;DATE&#125; $&#123;TIME&#125; */package $&#123;GO_PACKAGE_NAME&#125; 1234567/** * @Author: $&#123;USER&#125; * @Date: $&#123;DATE&#125; $&#123;TIME&#125; * @Description: */package $&#123;GO_PACKAGE_NAME&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言保证并发程序的数据安全性","slug":"golang/go-concurrent-safe","date":"2020-06-02T03:24:02.000Z","updated":"2022-11-19T08:07:54.466Z","comments":true,"path":"2020/06/02/golang/go-concurrent-safe/","link":"","permalink":"https://hqd8080.github.io/2020/06/02/golang/go-concurrent-safe/","excerpt":"","text":"并发安全 1.使用chan 2.使用原子性函数atomic函数 3.使用互斥锁sync.mutex 4.使用等待组sync.waitgroup 5.使用context系列函数超时退出","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Dockerfile文件常用指令","slug":"docker/docker-dockerfile","date":"2020-05-26T08:58:17.000Z","updated":"2022-11-08T07:22:50.092Z","comments":true,"path":"2020/05/26/docker/docker-dockerfile/","link":"","permalink":"https://hqd8080.github.io/2020/05/26/docker/docker-dockerfile/","excerpt":"","text":"Dockerfile文件常用指令说明 FROM:指定所创建镜像的基础镜像，任何Dockerfile中第一条指令必须为FROM指令 12# 基础镜像FROM ubuntu:18.04 LABEL:指定镜像添加元数据标签信息，用来补助过滤特定镜像 12# 维护者 LABEL maintainer hqd8080&lt;github.com/hqd8080&gt; EXPOSE:声明镜像内服务监听的端口 12# 开放端口EXPOSE 22 ENV:指定环境变量，在镜像生成过程中被后续RUN指令使用 12ENV APP_VERSION=1.0ENV APP_HOME=/usr/local/app ENTRYPOINT:指定镜像的默认入口命令，启动容器时作为根命令执行，每个Dockerfile文件只能有一个ENTRYPOINT VOLUME:创建一个数据卷挂载点 WORKDIR:配置工作目录；为后续的RUN，CMD，ENTRYPOINT指令配置工作目录","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Docker镜像SSH服务","slug":"docker/docker-ssh","date":"2020-05-26T03:22:56.000Z","updated":"2022-11-08T07:22:49.804Z","comments":true,"path":"2020/05/26/docker/docker-ssh/","link":"","permalink":"https://hqd8080.github.io/2020/05/26/docker/docker-ssh/","excerpt":"","text":"创建目录和文件123mkdir sshd_buildercd sshd_buildertouch Dockerfile run.sh 编写run.sh脚本和authorized_keys文件123#run.sh#!/bin/bash/usr/sbin/sshd -D 1cat ~/.ssh/id_rsa.pub &gt;authorized_keys 编写Dockerfile文件12345678910111213141516171819202122232425262728293031323334353637383940# 基础镜像FROM ubuntu:18.04# 维护者 LABEL maintainer hqd8080&lt;github.com/hqd8080&gt;# 更换为163源码RUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse&quot; &gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update # 安装ssh服务RUN apt-get install -y openssh-serverRUN mkdir -p /var/run/sshdRUN mkdir -p /root/.ssh# 取消pam限制RUN sed -ri &#x27;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&#x27; /etc/pam.d/sshd# 复制文件到容器ADD authorized_keys /root/.ssh/authorized_keysADD run.sh /run.sh# 修改执行权限RUN chmod 755 /run.sh# 开放端口EXPOSE 22# 设置自启动命令CMD [ &quot;/run.sh&quot; ] 创建镜像12cd sshd_builderdocker build -t sshd_ubuntu:v1 . 运行容器1docker run -d -p 2222:22 sshd_ubuntu 连接容器1ssh 192.168.0.200 -p 2222 github地址https://github.com/hqd8080/sshd_builder","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Git常用命令整理","slug":"git/git-command","date":"2020-05-24T10:40:28.000Z","updated":"2022-11-08T07:22:50.518Z","comments":true,"path":"2020/05/24/git/git-command/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/git/git-command/","excerpt":"","text":"Git常用命令整理初始化设置123git config --global user.name &quot;&lt;用户名&gt;&quot; #设置用户名git config --global user.email &quot;&lt;电子邮件&gt;&quot; #设置电子邮件 本地操作12345git add [-i] #保存更新，-i为逐个确认git status #检查更新git commit [-a] -m &quot;&lt;更新说明&gt;&quot; #提交更新，-a为(all)包含内容修改和增删，-m为说明信息，也可以使用 -am 远端操作123456789101112131415161718192021git clone #克隆项目到本地git fetch #远端抓取git merge #与本地当前分支合并git pull [&lt;远端别名&gt;] [&lt;远端branch&gt;] #抓取并合并,相当于第2、3步git push [-f] [&lt;远端别名&gt;] [&lt;远端branch&gt;] #推送到远端，-f为强制覆盖git remote add &lt;别名&gt; #设置远端别名git remote [-v] #列出远端，-v为详细信息git remote show &lt;远端别名&gt; #查看远端信息git remote rename &lt;远端别名&gt; &lt;新远端别名&gt; #重命名远端git remote rm &lt;远端别名&gt; #删除远端git remote update [&lt;远端别名&gt;] #更新分支列表 分支相关12345678910111213git branch [-r] [-a] #列出分支，-r远端 ,-a全部git branch &lt;分支名&gt; #新建分支git branch -b &lt;分支名&gt; #新建并切换分支git branch -d &lt;分支名&gt; #删除分支git checkout &lt;分支名&gt; #切换到分支git checkout -b &lt;本地branch&gt; [-t &lt;远端别名&gt;/&lt;远端分支&gt;] #-b新建本地分支并切换到分支, -t绑定远端分支git merge &lt;分支名&gt; #合并某分支到当前分支 Git使用例子1234workspace:本地的工作目录（记作A）index:缓存区域，临时保存本地改动（记作B）local repository:本地仓库，只想最后一次提交HEAD（记作C）remote repository:远程仓库（记作D） 初始化1234567git init #项目初始化git clone /path/to/repository #检出，可重命名git config --global user.email &quot;you@163.com&quot; #配置emailgit config --global user.name &quot;hqd8080&quot; #配置用户名 操作1234567891011121314151617181920git add # 文件添加，A → Bgit add . # 所有文件添加，A → Bgit commit -m &quot;代码提交信息&quot; # 文件提交，B → Cgit commit --amend # 与上次commit合并, *B → Cgit push origin master # 推送至master分支, C → Dgit pull # 更新本地仓库至最新改动， D → Agit fetch # 抓取远程仓库更新， D → Cgit log # 查看提交记录,git log -5git status # 查看修改状态git diff # 查看详细修改内容git show # 显示某次提交的内容 撤销操作1234567891011git reset # 某个文件索引会回滚到最后一次提交， C → Bgit reset # 索引会回滚到最后一次提交， C → Bgit reset --hard # 索引会回滚到最后一次提交， C → B → Agit checkout # 从index复制到workspace， B → Agit checkout -- files # 文件从index复制到workspace， B → Agit checkout HEAD -- files # 文件从local repository复制到workspace， C → A 分支相关1234567891011git checkout -b branch_name # 创建名叫“branch_name”的分支，并切换过去git checkout master # 切换回主分支git branch -d branch_name # 删除名叫“branch_name”的分支git push origin branch_name # 推送分支到远端仓库git merge branch_name # 合并分支branch_name到当前分支(如master)git rebase # 衍合，线性化的自动， D → A 冲突处理1234567git diff # 对比workspace与indexgit diff HEAD # 对于workspace与最后一次commitgit diff # 对比差异git add # 修改完冲突，需要add以标记合并成功 其他1234567gitk # 开灯图形化gitgit config color.ui true # 彩色的 git 输出git config format.pretty oneline # 显示历史记录时，每个提交的信息只显示一行git add -i # 交互式添加文件到暂存区","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"Docker常用命令说明（总结）","slug":"docker/docker-summary","date":"2020-05-24T09:01:26.000Z","updated":"2021-08-31T08:34:15.000Z","comments":true,"path":"2020/05/24/docker/docker-summary/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-summary/","excerpt":"","text":"获取镜像： 1234sudo docker pull ubuntu #(ubuntu:latest,获取最新版本的镜像)sudo docker pull ubuntu:14.04 #(指定标签来下载指定版本的镜像)sudo docker pull registory.hub.docker.com/ubutu:latest #(相当于以上两个命令的组合)sudo docker pull dl.dockerpoll.com:5000/ubuntu #从dl.dockerpoll.com下载镜像 利用镜像创建容器，在其中运行bash: 1sudo docker run -t -i ubuntu /bin/bash 查看本地已有镜像： 12sudo docker imagessudo docker images -a 创建新的标签: ＃（使用docker tag创建新的标签d.dockerpoll.com:5000/ubuntu:latest） 123sudo docker tag d.dockerpoll.com:5000/ubuntu:latest ubuntu:latestsudo docker inspect image id #查看镜像的详细信息,json格式sudo docker inspect -f &#123;&#123;.Architecture&#125;&#125; 550 #查看其中的一项信息 搜索镜像： 12sudo docker search #搜索远端仓库中共享的镜像，默认搜索docker Hub官方仓库的镜像sudo docker search mysql 删除镜像： 123sudo docker rmi IMAGEsudo docker rmi dl.dockerpool.com:20000/ubuntusudo docker rmi -f ubuntu #强制删除镜像（有容器在运行时和存在要删除的镜像容器一般删除不了） 不推荐强制删除镜像，正确的做法是，先删除镜像的容器然后在删除镜像 1sudo docker ps -a #查看本机上存在的所有容器 创建镜像：（３种） #1.基于已有镜像的容器创建 基于本地模板导入#2.基于Dockerfile创建#3.基于已有镜像的容器创建： 1sudo docker run -ti ubuntu:14.04 /bin/bash #(基于ubuntu14.04创建) 记住容器ID xxxxx 1sudo docker commit -m&quot;Added a new file&quot; -a &quot;docker newbee&quot; xxxxx test #test是tag 基于本地模板导入： 1sudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 存入和载入镜像 12存入镜像：sudo docker save -o ubuntu_14.04.tar ubuntu:14.04载入镜像：sudo docker load -input ubuntu_14.04.tar 或者 sudo docker load &lt; ubuntu_14.04.tar 上传镜像： 12sudo docker tar test:latest user/test:latestsudo docker push user/test:latest 新建容器 12345sudo docker create -it ubuntu:latestsudo docker ps -asudo docker startsudo docker run ubuntu /bin/echo &#x27;hello world&#x27;sudo docker run -t -i ubuntu:14.04 /bin/bash (启动一个bash终端,允许用户进行交互)，-t: 让docker分配一个伪终端,并绑定到容器的标准输入上-i：让容器的标准输入保持打开 终止容器： 1234sudo docker stop ce5sudo docker ps -a -q#查看终止状态的容器ID信息sudo docker start ce5#启动终止状态的容器sudo docker restart ce5#启动终止状态的容器 进入容器： 1sudo docker exec -ti 容器ID /bin/bash 删除容器： 123sudo docker ps -asudo docker rm 容器IDsudo docker rm -f 容器ID 导入和导出容器： 12sudo docker export ce5&gt;test_for_run_tarcat test_for_run_tar | sudo docker import - test/ubuntu:v1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker容器container","slug":"docker/docker-container","date":"2020-05-24T08:59:56.000Z","updated":"2021-09-01T09:14:26.000Z","comments":true,"path":"2020/05/24/docker/docker-container/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-container/","excerpt":"","text":"Docker容器容器是镜像的一个运行实例，所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层1234docker create -it ubuntu:latest //(处于停止状态,docker start启动)docker ps -a //查看所有的容器docker start 容器id //启动docker stop 容器id //停止 创建容器并启动容器123456docker run ubuntu /bin/echo &#x27;hello world&#x27;(自动终止)docker run -it ubuntu:18.04 /bin/bash#(启动一个bash终端,允许用户进行交互)#-t: 让docker分配一个伪终端,并绑定到容器的标准输入上#-i：让容器的标准输入保持打开 守护态运行1234567docker run -d ubuntu /bin/sh -c &quot;test&quot;#终止容器docker stop ce5docker ps -a -q #查看终止状态的容器ID信息docker start ce5 #启动终止状态的容器docker restart ce5 #启动终止状态的容器 查看某个容器的输出日志1docker logs ce554267d7a4 进入容器（最为推荐的方式）1docker exec -it 容器ID /bin/bash 删除容器（只能删除处于终止状态或退出状态的容器，不能删除运行状态的容器）123456sudo docker ps -asudo docker rm 容器IDsudo docker rm -f 容器ID#查看正在运行的容器docker ps 导入和导出容器：123docker export ce5&gt;test_for_run_tarcat test_for_run_tar | docker import - test/ubuntu:v1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker的镜像image","slug":"docker/docker-image","date":"2020-05-24T08:58:48.000Z","updated":"2022-11-08T07:22:49.564Z","comments":true,"path":"2020/05/24/docker/docker-image/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-image/","excerpt":"","text":"Docker通过容器来打包应用，（环境和代码）Docker的三大核心概念： 1.镜像（image） 2.容器（container） 3.仓库（repository） 镜像：类似于虚拟机环境，只读的模板，镜像是创建容器的基础 容器：从镜像创建的应用运行实例，盒子，沙箱，互不可见，隔离 仓库：docker集中存放镜像的场所，类似代码仓库 Docker仓库和仓库注册服务器的关系仓库注册服务器是存放仓库的地方，每个仓库集中存放某一类镜像，通过不同的tag来区分(类似git管理) 注册服务器 --&gt; 创库 --&gt; 各种仓库的不同tag版本 将当前用户加入安装中自带的Docker组1sudo usermod -aG docker hqd8080 获取镜像123docker pull name:tag //(名称+标签)docker pull ubuntu:18.04 //默认从官方拉取docker pull ubuntu //下载最新的镜像,默认是(ubuntu:latest) 从网易丰巢下载镜像1docker pull hub.c.163.com/public/ubuntu:18.04 通过镜像创建容器1docker run -it ubuntu:18.04 bash 查看镜像信息12docker imagesdocker images -a 使用tag给已经存在的镜像打标签1docker tag ubuntu:18.04 myubuntu:latest 使用history查看镜像历史,列出各层的创建信息123docker history ubuntu:18.04#详细信息(不截断)docker history ubuntu:18.04 --no-trunc 搜索镜像（远端仓库共享镜像|官方）1docker search ubuntu 删除镜像1234567891011docker rmi myubuntu:latestdocker images -a#使用镜像ID删除镜像的相关注意事项#有容器正在运行无法通过ID直接删除镜像，必须先删除依赖的容器，或者用-f强制删除docker run ubuntu:18.04 echo &#x27;hello hqd8080&#x27;docker ps -adocker rmi ubuntu:18.04docker rmi -f ubuntu:18.04docker rm a5212cvvbdgfsh // 使用镜像ID删除镜像 创建镜像的三种方法：1.基于已有的镜像的容器创建 123sudo docker run -ti ubuntu:18.04 /bin/bash #(基于ubuntu18.04创建)#记住容器ID xxxxxsudo docker commit -m&quot;Added a new file&quot; -a &quot;docker newbee&quot; xxxxx test #test是tag 2.基于本地模版导入创建 1sudo cat ubuntu-18.04-x86_64-minimal.tar.gz | docker import - ubuntu:18.04 3.基于dockerfile创建 存入和载入镜像12345#存入镜像sudo docker save -o ubuntu_18.04.tar ubuntu:18.04#载入镜像sudo docker load —input ubuntu_18.04.tar 或者 sudo docker load &lt; ubuntu_18.04.tar","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"理解Docker的仓库","slug":"docker/docker-warehouse","date":"2020-05-24T08:58:17.000Z","updated":"2021-09-01T09:26:03.000Z","comments":true,"path":"2020/05/24/docker/docker-warehouse/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-warehouse/","excerpt":"","text":"Docker仓库仓库是集中存放镜像的地方，可分为公共仓库和私有仓库 注册服务器是存放仓库的具体服务器，一个注册服务器可以有多个仓库，而每个仓库下面可以有多个镜像 private-docker.com/ubuntu:（private-docker.com是注册服务器ubuntu是仓库名） docker hub公共镜像市场 https://hub.docker.com/ 搜索官方镜像，并下载 123sudo docker search -s 5 centossudo docker pull cenros Docker数据管理容器数据管理的两种方式 数据卷：容器内数据直接映射到本地主机环境 数据卷容器：使用特定容器维护数据卷 数据卷：一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器 在容器内创建数据卷挂载一个主机目录作为数据卷 1docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py 加载主机目录/src/webapp到容器/opt/webapp使用training/webapp创建一个容器web 数据卷容器操作例子创建一个数据卷容器dbdata1docker run -it -v /dbdata --name dbdata ubuntu ok之后在其他容器中使用--volumes-from来挂载dbdata容器中的数据卷，例如db1,db2两个容器，并从dbdata容器挂载数据卷 docker run -it --volumes-from dbdata --name db1 ubuntu docker run -it --volumes-from dbdata --name db2 ubuntu 这样三个容器都能共享数据 端口映射和容器互联容器互联的使用 创建数据库容器 1docker run -d --name db training/postgres 创建一个新的web容器，并将它连接db容器 1docker run -d -P --name web --link db:db training/webapp python app.py 使用Dockerfile创建镜像 Dockerfile文本格式的配置文件 run命令：对镜像执行命令，每一个run指令，镜像就添加新的一层 cmd命令：对容器执行命令 指令说明： from：指定创建镜像的基础镜像 run：运行命令 cmd：指定启动容器时默认执行的指令 add：从主机复制文件到容器 copy：复制主机路径下的内容到容器，目标路径不存在时，会自动创建 创建镜像docker build .","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu16.04LTS安装docker","slug":"docker/docker-install-ubuntu1604","date":"2020-05-24T07:29:05.000Z","updated":"2021-09-01T08:28:56.000Z","comments":true,"path":"2020/05/24/docker/docker-install-ubuntu1604/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-ubuntu1604/","excerpt":"","text":"查看系统版本信息1cat /etc/issue Ubuntu 16.04.2 LTS \\n \\l 在ubuntu上简单的安装方法12sudo apt-get updatesudo apt-get install docker 搞定!（这种安装方法的缺点是安装的docker版本不是最新的版本）下面介绍推荐的安装docker方式 注意(Docker需要64的操作系统,此外你的kernel内核至少要在3.10版本之上)官方的参考文档： https://docs.docker.com/engine/installation/linux/ubuntulinux/ 12sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates 导入gpg密钥123sudo apt-key adv \\ —keyserver hkp://ha.pool.sks-keyservers.net:80 \\ —recv-keys 58118E89F3A912897C070ADBF76221572C52609D 添加docker源，其它版本添加请参照官方文档，官方只提供LTS版本的源找到对应版本的源地址，16.04对应到源地址为: 1deb https://apt.dockerproject.org/repo ubuntu-xenial main 执行命令添加源1echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; | sudo tee /etc/apt/sources.list.d/docker.list 更新源1sudo apt-get update 查看可安装列表(这步可以略过)1apt-cache policy docker-engine 安装 默认安装最近的版本1sudo apt-get install docker-engine 启动1sudo service docker start 运行hello world1sudo docker run hello-world 结果:123456789101112131415Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: The Docker client contacted the Docker daemon. The Docker daemon pulled the “hello-world” image from the Docker Hub. The Docker daemon created a new container from that image which runs theexecutable that produces the output you are currently reading. The Docker daemon streamed that output to the Docker client, which sent itto your terminal.To try something more ambitious, you can run an Ubuntu container with:$ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker Hub account:https://hub.docker.comFor more examples and ideas, visit:https://docs.docker.com/engine/userguide/ 如果出现网络问题无法下载，就先从网易蜂巢的镜像市场到hello-world运行docker run hub.c.163.com/library/hello-world 或者先pull后run1docker pull hub.c.163.com/library/hello-world:latest 以非管理员权限运行（每次运行要加sudo也不是事，对吧）创建docker用户组(默认已经创建)1sudo groupadd docker 将当前用户加到这个组里(不用改$USER这几个字，$USER这个环境变量就是指当前用户名) 1sudo usermod -aG docker $USER 再尝试运行1docker run hello-world 如果运行出现Cannot connect to the Docker daemon. Is the docker daemon running on this host? 官方文档提示你设置环境变量，其实没什么用，从网上看到很多结果都是无意中突然好了~ 事实上是因为加入用户组这个东西必须注销或重启才能生效，你注销或者重启一下马上就好了 常用命令1234docker version #查看版本docker images #查看镜像列表docker images -a #查看镜像列表docker rmi -f [镜像id] #删除指定镜像","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Dockerfile实战构建自己的基础镜像","slug":"docker/docker-create-base-img","date":"2020-05-24T07:14:39.000Z","updated":"2022-11-08T07:22:49.486Z","comments":true,"path":"2020/05/24/docker/docker-create-base-img/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-create-base-img/","excerpt":"","text":"以下是docker Hub上下载官方仓库的ubuntu14.04镜像(188M)，用它来构建合适自己的ubuntu基础镜像 12345678910111213141516171819202122#this dockerfile uses the ubuntu image使用docker Hub官方的ubuntu14.04镜像构建version 0.1author: hqd8080指定所创建镜像的基础镜像FROM ubuntu:14.04#维护者信息MAINTAINER github.com/hqd8080#指定镜像生成的元数据标签信息LABEL version=&quot;0.1&quot;LABEL description=&quot;ubuntu14.04 base image&quot;#将复制指定的文件到容器中#格式:ADD #例子:ADD *.c /code/ADD sources.list /etc/apt/#CMD用来启动容器时默认执行的命令CMD [&quot;/bin/bash&quot;] 构建sudo docker build -t=&quot;hqd8080/my_ubuntu:14.04_base_images&quot; . 123sudo docker build中-t表示容器的名字hqd8080/my_ubuntu中navas表示仓库名（不允许大写）,my_ubuntu表示镜像名my_ubuntu:14.04_base_images后的14.04_base_images是标签,如果没有指定,默认的是latest 1234#hqd8080$ tree.├── Dockerfile├── README.md└── sources.list(从我当前的系统复制过来) 12Successfully built 1a00f5985fdcSuccessfully tagged navas/my_ubuntu:14.04_base_images 查看镜像sudo docker images -a","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu安装docker-compose","slug":"docker/docker-install-decker-compose","date":"2020-05-24T06:52:29.000Z","updated":"2021-09-01T08:29:29.000Z","comments":true,"path":"2020/05/24/docker/docker-install-decker-compose/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-decker-compose/","excerpt":"","text":"docker-compose的下载地址为:https://github.com/docker/compose/releases 以下以docker-compose1.16.1版本安装为例子：1curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 1chmod +x /usr/local/bin/docker-compose 如果报错：bash: /usr/local/bin/docker-compose: 权限不够 请切换超级管理员sudo -i 然后再执行chmod +x /usr/local/bin/docker-compose 安装成功查看信息:docker-compose --version docker-compose version 1.16.1, build 6d1ac21","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Ubuntu系统docker解决sudo权限问题","slug":"docker/docker-power","date":"2020-05-24T06:41:02.000Z","updated":"2021-09-01T08:29:45.000Z","comments":true,"path":"2020/05/24/docker/docker-power/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-power/","excerpt":"","text":"如果还没有 docker group 就添加一个：1sudo groupadd docker 将用户加入该 group 内,然后退出并重新登录就生效1sudo gpasswd -a $&#123;USER&#125; docker 重启 docker 服务1systemctl restart docker 切换当前会话到新 group 或者重启 X 会话1newgrp - docker 注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效所以 docker images 执行时同样有错","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"Docker安装MySQL8.0","slug":"docker/docker-install-mysql","date":"2020-05-24T06:15:24.000Z","updated":"2021-08-31T08:34:15.000Z","comments":true,"path":"2020/05/24/docker/docker-install-mysql/","link":"","permalink":"https://hqd8080.github.io/2020/05/24/docker/docker-install-mysql/","excerpt":"","text":"Docker安装MySQL8.0拉取最新版mysql镜像docker pull mysql 查看镜像docker images -a 运行容器docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 123–name： 容器名，此处命名为mysql-e： 配置信息，此处配置mysql的root用户的登录密码-p： 端口映射，此处映射 主机3306端口 到 容器的3306端口 如果要建立目录映射 1234567docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:latest-v：主机和容器的目录映射关系，&quot;:&quot;前为主机目录，之后为容器目录 检查容器是否正确运行docker container ls | docker ps -a 进入容器 12docker exec -it mysql bashmysql -uroot -p123456 宿主机链接容器的mysql（远程连接mysql）我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问： 1234host: 127.0.0.1port: 3306user: rootpassword: 123456 如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因： caching_sha2_password问题为了提供更安全的密码加密MySQL8.0的首选默认认证插件是，caching_sha2_password而不是mysql_native_password 123456789101112131415mysql&gt; use mysql;mysql&gt; select host, user, plugin from user;+-----------+------------------+-----------------------+| host | user | plugin |+-----------+------------------+-----------------------+| % | root | mysql_native_password || localhost | mysql.infoschema | caching_sha2_password || localhost | mysql.session | caching_sha2_password || localhost | mysql.sys | caching_sha2_password || localhost | root | mysql_native_password |+-----------+------------------+-----------------------+ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;flush privileges; 或者 1234567docker exec -it mysql bashmysql -uroot -p123456配置 mysql.cnf 配置默认身份验证插件/etc/mysql/ [mysqld]default_authentication_plugin = mysql_native_password 防火墙阻拦 开放端口：systemctl status firewalldfirewall-cmd --zone=public --add-port=3306/tcp -permanentfirewall-cmd --reload 关闭防火墙：systemctl stop firewalld 需要进入docker本地客户端设置远程访问账号 1234docker exec -it mysql bashmysql -uroot -p123456grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;; mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改） 1234567891011121314151617use mysql;select host, user, plugin from user;+-----------+------------------+-----------------------+| host | user | plugin |+-----------+------------------+-----------------------+| % | root | mysql_native_password || localhost | mysql.infoschema | caching_sha2_password || localhost | mysql.session | caching_sha2_password || localhost | mysql.sys | caching_sha2_password || localhost | root | mysql_native_password |+-----------+------------------+-----------------------+grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;flush privileges;","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"}]},{"title":"清除项目Git版本控制信息","slug":"git/git-clear","date":"2020-05-23T12:40:28.000Z","updated":"2022-03-04T02:39:23.000Z","comments":true,"path":"2020/05/23/git/git-clear/","link":"","permalink":"https://hqd8080.github.io/2020/05/23/git/git-clear/","excerpt":"","text":"首先进入项目目录下: cd project 然后执行: find . -name &quot;.git&quot; | xargs rm -rf","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"分布式系统中的CAP原理","slug":"microservice/microservice-CAP","date":"2020-05-22T15:40:28.000Z","updated":"2022-04-14T06:14:33.000Z","comments":true,"path":"2020/05/22/microservice/microservice-CAP/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/microservice/microservice-CAP/","excerpt":"","text":"分布式系统中的CAP原理CAP：描述分布式系统下，节点数据同步的基本定理 1231.一致性2.可用性3.分区容忍性 以上三个指标不可能同时满足，分布式系统分区容忍性是必须要满足的","categories":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]},{"title":"微服务学习笔记","slug":"microservice/microservice","date":"2020-05-22T15:40:28.000Z","updated":"2022-04-14T06:14:33.000Z","comments":true,"path":"2020/05/22/microservice/microservice/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/microservice/microservice/","excerpt":"","text":"微服务学习微服务核心组件：1234567- 1.服务注册与发现- 2.远程过程调用RPC- 3.分布式配置中心- 4.微服务网关- 5.微服务的容错处理与负载均衡- 6.统一认证与授权- 7.分布式链式追踪 微服务设计的6大原则：123456- 1.高内聚，低耦合- 2.高度自治- 3.以业务为中心- 4.弹性设计- 5.日志与监控- 6.自动化 微服务架构：将单体应用转化为多个可以；独立开发；独立部署；独立运行；和独立维护的服务或者应用的集合； 微服务：是指将大型复杂软件应用拆分成多个简单应用；每个应用描述着一个小业务；系统中的应用可被独立部署；每个微服务仅关注于完成（单一职责）；分而治之 ；模块化； 微服务的特点：1234- 1.独立开发；独立部署；独立运行- 2.微服务之间采用RESTful API或者RPC等协议通信- 3.微服务遵循单一原则- 4.微服务一般使用容器部署 微服务的缺点：123- 1.服务拆分过多；服务治理成本较高；不利于系统维护；- 2.服务之间相互依赖；有可能形成复杂的依赖链条；出现服务雪崩效应；- 3.服务实例之间交互需要处理分布式事务，调用幂等和重试等问题； SOA和微服务的区别：1- SOA注重的是系统集成；而微服务关注的是完全分离； Go的微服务框架：12- 1.go-kit：应用程序架构由三部分组成：传输层；接口层；服务层；- 2.go-micro：插件化的RPC微服务框架；提供了（服务发现）；（负载均衡）；（同步传输）；（异步通信）；（事件驱动）； 组件化的微服务框架；组件是分层的；上层基于下层功能继续向上提供服务； go-micro框架中的组件介绍（7个）可插拔的架构设计理念：1234567- Registry：服务发现组件（提供服务发现机制；解析服务名称至服务地址；目前支持的注册中心；etcd;consul;zookeeper）- Selector：基于Registry的客户端负载均衡组件；client组件使用selector组件从Registry返回的服务列表中进行负载均衡选择；- Broker：发布和订阅组件；服务之间基于消息中间件的异步通信方式；kafka；rabbitMQ等；- Transport：服务之间同步通信方式- Codec：服务之间的编码和解码组件- Server：服务主体，对外提供 统一的服务请求入口- Client：提供访问微服务的客户端； go-kit和go-micro的区别：12- go-kit是一个微服务的标准库；go-kit提供了独立的包；通过这些包开发者可以组件自己的应用程序；- go-micro是一个面向微服务的可插拔RPC框架；它尝试使用组件的方式简化分布式系统之间的通信； 微服务设计的6大原则123456- 1.（高内聚，低耦合）单一职责；轻量级通信；服务之间的契约- 2.（高度自治）能独立开发；部署；发布；进程隔离；独立的代码库；流水线；- 3.（以业务为中心）每个微服务代表了特定的业务逻辑；能更快的响应业务变化；- 4.（弹性设计）容错；服务降级；- 5.（日志与容错）日志集合；监控和警告；- 6.（自动化）持续集成；持续交付； 领域驱动设计（DDD）领域驱动设计是一种思想；一种方法论；对软件系统进行合理拆分；最终的目标还是，高内聚，低耦合；领域驱动设计分层 （微服务的划分粒度）1234- 1.用户界面（表现层或接口层） User interface- 2.应用层 Application- 3.领域层 Domain - 4.基础实施层 Infrastructure","categories":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]},{"title":"Git flow","slug":"git/git-flow","date":"2020-05-22T12:40:28.000Z","updated":"2022-03-04T02:34:39.000Z","comments":true,"path":"2020/05/22/git/git-flow/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/git/git-flow/","excerpt":"","text":"git flow 1.master主分支，存放稳定的项目版本，这个分支主要是从别的分支合并过来，不会直接在这个分支上提交 2.develop开发分支，当要新增新功能时，所有的feature分支都是从这个分支划分出去的，而feature分支功能完成后也会合并回develop分支 3.hotfix分支，当线上发生紧急问题时，从master分支划分出hotfix进行紧急问题修复，修复完成合并回master，同时合并回develop分支 4.release分支，发布线上分支，develop分支足够成熟可合并到release分支 5.feature分支，新增功能的分支，从develop分支划出，完成后合并回develop分支 新建新分支1git branch new-branch 新建分支并且切换至新分支1git checkout -b new-branch 查看分支123git branch 当前分支git branch -a 所有分支git branch -r 远程分支 修改分支名称，development改成develop1git branch -m development develop 删除分支1git branch -d develop 强制删除，还没合并的分支也能删除1git branch -D dev 查看提交记录1git log --oneline git切换分支做的事情 1.更新暂存区和工作目录 2.变更HEAD的位置","categories":[{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"}]},{"title":"Go语言启动10个goroutine处理任务的例子","slug":"golang/go-chan","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-19T08:07:54.471Z","comments":true,"path":"2020/05/22/golang/go-chan/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-chan/","excerpt":"","text":"Go语言启动10个goroutine处理任务的例子 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; channels := make([]chan int, 10) for i := 0; i &lt; 10; i++ &#123; channels[i] = make(chan int) go process(channels[i]) &#125; for i, ch := range channels &#123; &lt;-ch fmt.Println(&quot;routine:&quot;, i, &quot;quit&quot;) &#125;&#125;func process(ch chan int) &#123; // 模拟处理任务 time.Sleep(time.Second) ch &lt;- 1&#125; 输出 12345678910routine: 0 quitroutine: 1 quitroutine: 2 quitroutine: 3 quitroutine: 4 quitroutine: 5 quitroutine: 6 quitroutine: 7 quitroutine: 8 quitroutine: 9 quit","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言字符串和数据类型转换总结","slug":"golang/go-data-type-convert","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-19T08:07:54.474Z","comments":true,"path":"2020/05/22/golang/go-data-type-convert/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-data-type-convert/","excerpt":"","text":"Go语言字符串和数据类型转换总结 字符串转数字 12345// string to int int, err := strconv.Atoi(string)// string to int64int64, err := strconv.ParseInt(string, 10, 64) 数字转字符串 12345// int to string string := strconv.Itoa(int)// int64 to string string := strconv.FormatInt(int64, 10)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的G-P-M模型","slug":"golang/go-gmp","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-19T08:07:54.468Z","comments":true,"path":"2020/05/22/golang/go-gmp/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-gmp/","excerpt":"","text":"Go语言的G-P-M模型G：goroutine,表示一个协程对象，用go关键字加函数调用即可创建一个G对象，它是对并发执行任务的封装，也可以看作是一种特殊的协程，G属于用户级资源，对操作系统透明，非常轻量级，可以大量创建，且上下文切换成本比较低 M：machine的简称，可以看作是利用系统调用创建出来的操作系统上的线程实体，M的作用就是执行G中封装的并发任务，M属于操作系统资源，可创建的数量受限于操作系统， 一般来说G的数量都多于M的数量 P：processor的简称，表示逻辑处理器，每个P都有一个G队列，主要用于管理G对象，并为G在M上的运行提供本地化资源 M与P是一对一的关系，M会从P的本地队列中弹出一个可运行状态的G来执行，如果P中的本地队列为空，就会执行窃取 进程，线程，协程的概念进程：process，进程是操作系统进行资源分配和调度的基本单位，是操作系统结构的基础，每个进程都有自己的独立内存空间，不同进程通过；进程间的通信机制来通信，进程间上下文的切换开销比较大，但相对比较稳定，安全。从理论上来讲，进程是对正在运行的程序过程的抽象 线程：thread，线程是进程中的一个实体，拥有自己独立的栈和共享堆，线程的切换一般是由操作系统调度，进程和线程是一对多的关系；一个进程由多个线程构成，而一个线程必属于一个进程 协程：goroutine，又称为轻量级的线程，协程是一种用户态的轻量级线程，调度完全由用户控制，协程拥有自己的寄存器上下文和栈，上下文的切换非常快，一个线程可以由多个协程组成 线程和协程的主要区别线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，那么它就会被其他可执行的线程抢占；协程的调度是协同式的，在协同式调度中没有时间片的概念，为了并发执行协程，调度器会在以下几种时间点对其进行切换： 1通道channel接收或者发送会造成阻塞的消息 2垃圾回收 3文件和网络操作","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言使用反射获取结构体中的Tag信息","slug":"golang/go-reflect","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-19T08:07:54.441Z","comments":true,"path":"2020/05/22/golang/go-reflect/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-reflect/","excerpt":"","text":"Go语言使用反射获取结构体中的Tag信息 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Cat struct &#123; Name string Attr string `json:&quot;attr&quot; id:&quot;222&quot;`&#125;func main() &#123; ins := Cat&#123; Name: &quot;BBA&quot;, Attr: &quot;BNW&quot;, &#125; t := reflect.TypeOf(ins) for i := 0; i &lt; t.NumField(); i++ &#123; field := t.Field(i) fmt.Println(field.Name) fmt.Println(field.Type) fmt.Println(field.Tag) &#125; fmt.Println(&quot;--------------------------&quot;) if f, ok := t.FieldByName(&quot;Attr&quot;); ok &#123; fmt.Println(f.Tag.Get(&quot;json&quot;)) fmt.Println(f.Tag.Get(&quot;id&quot;)) &#125;&#125; 12345678910NamestringAttrstringjson:&quot;attr&quot; id:&quot;222&quot;--------------------------attr222","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言启动4个协程处理10个任务的例子","slug":"golang/go-work","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-19T08:07:54.455Z","comments":true,"path":"2020/05/22/golang/go-work/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/golang/go-work/","excerpt":"","text":"Go语言启动4个协程处理10个任务的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot;)const ( numberGoroutines = 4 taskLoad = 10)var wg sync.WaitGroupfunc init() &#123; rand.Seed(time.Now().Unix())&#125;func main() &#123; tasks := make(chan string, taskLoad) wg.Add(numberGoroutines) for i := 1; i &lt;= numberGoroutines; i++ &#123; go work(tasks, i) &#125; for post := 1; post &lt;= taskLoad; post++ &#123; tasks &lt;- fmt.Sprintf(&quot;Task:%d&quot;, post) &#125; close(tasks) wg.Wait()&#125;func work(tasks chan string, worker int) &#123; defer wg.Done() for &#123; task, ok := &lt;-tasks if !ok &#123; fmt.Printf(&quot;worker:%d shutting down(关闭)\\n&quot;, worker) return &#125; fmt.Printf(&quot;Worker:%d started %s\\n&quot;, worker, task) sleep := rand.Int63n(100) time.Sleep(time.Duration(sleep) * time.Millisecond) fmt.Printf(&quot;Worker:%d completed %s\\n&quot;, worker, task) &#125;&#125; 输出： 123456789101112131415161718192021222324Worker:4 started Task:1Worker:2 started Task:2Worker:1 started Task:4Worker:3 started Task:3Worker:4 completed Task:1Worker:4 started Task:5Worker:3 completed Task:3Worker:3 started Task:6Worker:3 completed Task:6Worker:3 started Task:7Worker:1 completed Task:4Worker:1 started Task:8Worker:2 completed Task:2Worker:2 started Task:9Worker:2 completed Task:9Worker:2 started Task:10Worker:3 completed Task:7worker:3 shutting down(关闭)Worker:4 completed Task:5worker:4 shutting down(关闭)Worker:1 completed Task:8worker:1 shutting down(关闭)Worker:2 completed Task:10worker:2 shutting down(关闭)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Redis哈希类型（hash）的使用","slug":"redis/redis-hash","date":"2020-05-22T12:40:28.000Z","updated":"2022-11-08T07:22:49.650Z","comments":true,"path":"2020/05/22/redis/redis-hash/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-hash/","excerpt":"","text":"Redis哈希类型（hash）的使用 哈希表示字段和值之间的映射关系 12345// 一次性设置和获取多个哈希属性键值127.0.0.1:6379&gt; hmset &quot;hqd8080&quot; &quot;phone&quot; &quot;18111111111&quot; &quot;address&quot; &quot;shanghai china&quot;127.0.0.1:6379&gt; hmget &quot;hqd8080&quot; &quot;phone&quot; &quot;address&quot;1) &quot;18111111111&quot;2) &quot;shanghai china&quot; 12// 获取哈希的一个属性hget127.0.0.1:6379&gt; hget hqd8080 address 12// 测试哈希中是否存在某个字段、属性，hexists127.0.0.1:6379&gt; hexists hqd8080 &quot;phone&quot; 123456// 获取哈希中的所有字段 hgetall127.0.0.1:6379&gt; hgetall hqd80801) &quot;phone&quot;2) &quot;18111111111&quot;3) &quot;address&quot;4) &quot;shanghai china&quot; 12345// 删除哈希中的摸个字段，hdel127.0.0.1:6379&gt; hdel hqd8080 &quot;phone&quot;127.0.0.1:6379&gt; hgetall hqd80801) &quot;address&quot;2) &quot;shanghai china&quot; 12// 仅当哈希字段不存在时才创建，避免hmset的覆盖字段行为127.0.0.1:6379&gt; hsetnx &quot;hqd8080&quot; &quot;phone&quot; &quot;11111111111&quot; 1234567// 哈希字段非常多建议使用hscan，是一种指针迭代器，不会造成服务器阻塞，适合非常大的哈希127.0.0.1:6379&gt; hscan hqd8080 0 match &quot;*a*&quot;1) &quot;0&quot; // 服务器返回的新游标，用来进行一次新的迭代，0代表哈希遍历完成2) 1) &quot;address&quot;2) &quot;shanghai china&quot;127.0.0.1:6379&gt; hscan hqd8080 新游标 match &quot;*a*&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis类型（HyperLogLog）的使用","slug":"redis/redis-hyperLogLog","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:40:11.000Z","comments":true,"path":"2020/05/22/redis/redis-hyperLogLog/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-hyperLogLog/","excerpt":"","text":"Redis类型HyperLogLog的使用 唯一计数 HyperLogLog 123456// 根据uid统计访问次数，去重127.0.0.1:6379&gt; pfadd &quot;count&quot; 12343127.0.0.1:6379&gt; pfadd &quot;count&quot; 2127.0.0.1:6379&gt; pfcount count // 2 位图节约存储空间，底层数据类型是字符串 设置键的过期时间原理：设置键的过期时间会被存储为一个绝对的UNIX时间戳；即使redis服务器宕机了一段时间；这个时间戳也会被持久化到RDB文件中；当redis再次启动时这个用来判断是否过期的时间戳并不会发生变化，一旦当前的时间戳超过这个保存的时间戳，键就过期了 被动过期：在一个键过期后，当试图访问已经过期的键时；redis会立即从内存中删除","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis列表类型（list）的使用","slug":"redis/redis-list","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:22:53.000Z","comments":true,"path":"2020/05/22/redis/redis-list/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-list/","excerpt":"","text":"Redis列表类型（list）的使用 12// 从左边插入列表127.0.0.1:6379&gt; lpush shanghai &quot;长宁区&quot; &quot;徐汇区&quot; &quot;静安区&quot; &quot;浦东区&quot; &quot;黄浦区&quot; &quot;普陀区&quot; 12// 列表打印127.0.0.1:6379&gt; lrange shanghai 0 -1 12// 从右边插入列表127.0.0.1:6379&gt; rpush shanghai &quot;songjiangqu&quot; 12// songjiangqu之后插入&quot;嘉定区&quot;127.0.0.1:6379&gt; linsert shanghai after &quot;songjiangqu&quot; &quot;嘉定区&quot; 123// 使用索引获取值127.0.0.1:6379&gt; lindex shanghai 6&quot;songjiangqu&quot; 12// 仅在列表存在时才插入列表 lpushx rpushx,列表不存在返回(empty array)127.0.0.1:6379&gt; lpushx shanghai &quot;test&quot; 12345// lpop，rpop移除列表的元素127.0.0.1:6379&gt; lpop shanghai // 从左边移除一个元素127.0.0.1:6379&gt; lrange shanghai 0 -1127.0.0.1:6379&gt; rpop shanghai // 从右边移除一个元素127.0.0.1:6379&gt; lrange shanghai 0 -1 12// 阻塞版本blpop，brpop 阻塞版本会将客户端阻塞，当设置超时时间为0时表示永久等待127.0.0.1:6379&gt; brpop job_queue 0","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis的持久化","slug":"redis/redis-rdb-aof","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:43:12.000Z","comments":true,"path":"2020/05/22/redis/redis-rdb-aof/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-rdb-aof/","excerpt":"","text":"Redis的持久化 redis有两种数据持久化类型：RDB和AOF RDB可以看做是某个时间点上的快照，非常适合于备份和灾难恢复（仅包含某个时间点上的redis数据快照）AOF（append-only file）则是一个写入操作的日志，将在服务器启动时被重放（只记录redis写入的追加式日志文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性比RDB更高） 在一个正在运行的redis实例上启用AOF持久化 1127.0.0.1:6379&gt; config set appendonly yes 在配置文件中开启 1cat conf/redis.conf |grep &quot;^appendonly yes&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis集合类型（set）的使用","slug":"redis/redis-set","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:31:30.000Z","comments":true,"path":"2020/05/22/redis/redis-set/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-set/","excerpt":"","text":"Redis集合类型（set）的使用 集合类型，唯一，无序对象，应用场景：求差集，交集，并集 12// 添加进集合，sadd127.0.0.1:6379&gt; sadd &quot;develop_language&quot; &quot;Go&quot; &quot;PHP&quot; &quot;Python&quot; &quot;Java&quot; &quot;C++&quot; 12// 集合中成员数量，scard127.0.0.1:6379&gt; scard develop_language 12// 测试元素是不是在集合中，sismember127.0.0.1:6379&gt; sismember develop_language &quot;Go&quot; 12// 删除集合的一个元素,srem127.0.0.1:6379&gt; srem develop_language &quot;C++&quot; 123456// 列出集合中的所有元素，smembers127.0.0.1:6379&gt; smembers develop_language1) &quot;Python&quot;2) &quot;PHP&quot;3) &quot;Go&quot;4) &quot;Java&quot; 1234// 计算两个集合的并集，sunion（只返回结果），sunionstort（将结果存储到一个指定的键中）// 计算交集127.0.0.1:6379&gt; sinter &quot;集合1&quot; &quot;集合2&quot;127.0.0.1:6379&gt; sinterstore &quot;集合1&quot; &quot;集合2&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis字符串类型（string）的使用","slug":"redis/redis-string","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:18:43.000Z","comments":true,"path":"2020/05/22/redis/redis-string/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-string/","excerpt":"","text":"Redis字符串类型（string）的使用 123// 设置key，value127.0.0.1:6379&gt; set address &quot;shanghai china&quot; 12// 获取key对应的value127.0.0.1:6379&gt; get address // &quot;shanghai china&quot; 12// 返回字符串长度，key不存在返回0127.0.0.1:6379&gt; strlen address // (integer) 14 12// 字符串追加，拼接127.0.0.1:6379&gt; append address &quot; chang ning&quot; // &quot;shanghai china chang ning&quot; 12// 仅在key不存在时，才设置键的值，键已经存在返回0127.0.0.1:6379&gt; setnx address &quot;test&quot; 1234567// mset，mget原子性的一次性的设置多个键值127.0.0.1:6379&gt; mset &quot;pudong&quot; &quot;001&quot; &quot;changning&quot; &quot;002&quot; &quot;xuhui&quot; &quot;003&quot;127.0.0.1:6379&gt; mget &quot;pudong&quot; &quot;changning&quot; &quot;xuhui&quot;1) &quot;001&quot;2) &quot;002&quot;3) &quot;003&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Redis有序集合类型（zset）的使用","slug":"redis/redis-zset","date":"2020-05-22T12:40:28.000Z","updated":"2021-09-01T16:35:06.000Z","comments":true,"path":"2020/05/22/redis/redis-zset/","link":"","permalink":"https://hqd8080.github.io/2020/05/22/redis/redis-zset/","excerpt":"","text":"Redis有序集合类型（zset）的使用 12// 添加进有序集合127.0.0.1:6379&gt; zadd develop:language 100 &quot;Go&quot; 88 &quot;PHP&quot; 80 &quot;Python&quot; 60 &quot;Java&quot; 55 &quot;C++&quot; 123456789101112// 获取排名，从大到小，zrevrange127.0.0.1:6379&gt; zrevrange develop:language 0 -1 withscores1) &quot;Go&quot;2) &quot;100&quot;3) &quot;PHP&quot;4) &quot;88&quot;5) &quot;Python&quot;6) &quot;80&quot;7) &quot;Java&quot;8) &quot;60&quot;9) &quot;C++&quot;10) &quot;55&quot; 12// 集合的元素scores操作加1127.0.0.1:6379&gt; zincrby develop:language 1 &quot;Go&quot; 12// 只查看某个有序集合的元素排名，zrevrange127.0.0.1:6379&gt; zrevrange develop:language &quot;Go&quot; 12// 只查看某个有序集合的数值, zscore127.0.0.1:6379&gt; zscore develop:language &quot;Go&quot; 12345678910111213141516// 添加新的有序集合成员127.0.0.1:6379&gt; zadd develop:language nx 50 &quot;Rust&quot;// 查看127.0.0.1:6379&gt; zrevrange develop:language 0 -1 withscores1) &quot;Go&quot;2) &quot;101&quot;3) &quot;PHP&quot;4) &quot;88&quot;5) &quot;Python&quot;6) &quot;80&quot;7) &quot;Java&quot;8) &quot;60&quot;9) &quot;C++&quot;10) &quot;55&quot;11) &quot;Rust&quot;12) &quot;50&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"}]},{"title":"Go语言解析复杂格式json数据（simplejson包）","slug":"golang/go-simplejson","date":"2020-05-14T13:03:20.000Z","updated":"2022-11-19T08:07:54.445Z","comments":true,"path":"2020/05/14/golang/go-simplejson/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-simplejson/","excerpt":"","text":"Go语言使用第三方包simplejson包，解析复杂结构的json数据实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942#request.json&#123; &quot;requestType&quot;: &quot;services.UserLoginRequest&quot;, &quot;requestStream&quot;: false, &quot;messageTypes&quot;: &#123; &quot;google.protobuf.Timestamp&quot;: [&#123; &quot;name&quot;: &quot;seconds&quot;, &quot;protoName&quot;: &quot;seconds&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;0&quot; &#125;, &#123; &quot;name&quot;: &quot;nanos&quot;, &quot;protoName&quot;: &quot;nanos&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: 0 &#125;], &quot;services.UserLoginRequest&quot;: [&#123; &quot;name&quot;: &quot;userId&quot;, &quot;protoName&quot;: &quot;user_id&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;100&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 16947 &#125;, &#123; &quot;name&quot;: &quot;userName&quot;, &quot;protoName&quot;: &quot;user_name&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;zhangsan&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 14965 &#125;, &#123; &quot;name&quot;: &quot;userNickname&quot;, &quot;protoName&quot;: &quot;user_nickname&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;xiaoming&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 15598 &#125;, &#123; &quot;name&quot;: &quot;userCountry&quot;, &quot;protoName&quot;: &quot;user_country&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;china&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 48380 &#125;, &#123; &quot;name&quot;: &quot;userGender&quot;, &quot;protoName&quot;: &quot;user_gender&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 67007 &#125;, &#123; &quot;name&quot;: &quot;userCredits&quot;, &quot;protoName&quot;: &quot;user_credits&quot;, &quot;type&quot;: &quot;double&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;100.0&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91280 &#125;, &#123; &quot;name&quot;: &quot;isAdmin&quot;, &quot;protoName&quot;: &quot;is_admin&quot;, &quot;type&quot;: &quot;bool&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: true, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 85770 &#125;, &#123; &quot;name&quot;: &quot;authCode&quot;, &quot;protoName&quot;: &quot;auth_code&quot;, &quot;type&quot;: &quot;bytes&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;123&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 36294 &#125;, &#123; &quot;name&quot;: &quot;userBalance&quot;, &quot;protoName&quot;: &quot;user_balance&quot;, &quot;type&quot;: &quot;float&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;200.00&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 94647 &#125;, &#123; &quot;name&quot;: &quot;userHobby&quot;, &quot;protoName&quot;: &quot;user_hobby&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.Hobby&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;music&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91930 &#125;, &#123; &quot;name&quot;: &quot;luckyNumbers&quot;, &quot;protoName&quot;: &quot;lucky_numbers&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: true, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;2&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;4&quot;, &quot;value&quot;: 1, &quot;parentType&quot;: &quot;int32&quot;, &quot;id&quot;: 77877, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;6&quot;, &quot;value&quot;: 1, &quot;parentType&quot;: &quot;int32&quot;, &quot;id&quot;: 21349, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 51439 &#125;, &#123; &quot;name&quot;: &quot;userEmail&quot;, &quot;protoName&quot;: &quot;user_email&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserEmailEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416010481, &quot;name&quot;: &quot;userEmail-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;email001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 35094, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 11786, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416021145, &quot;name&quot;: &quot;userEmail-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;email002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 49850, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 82232, &quot;parentName&quot;: &quot;userEmail&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 49491 &#125;, &#123; &quot;name&quot;: &quot;userWeight&quot;, &quot;protoName&quot;: &quot;user_weight&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserWeightEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416029666, &quot;name&quot;: &quot;userWeight-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;weight1&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 1295, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;10&quot;, &quot;value&quot;: 0, &quot;id&quot;: 3455, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416048040, &quot;name&quot;: &quot;userWeight-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;weight2&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 86596, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;10&quot;, &quot;value&quot;: 0, &quot;id&quot;: 77749, &quot;parentName&quot;: &quot;userWeight&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 32487 &#125;, &#123; &quot;name&quot;: &quot;userNum&quot;, &quot;protoName&quot;: &quot;user_num&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.UserNumEntry&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: true, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &#123;&#125;, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416067640, &quot;name&quot;: &quot;userNum-0&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userNum&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1001&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 26160, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1001001&quot;, &quot;id&quot;: 63268, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;id&quot;: 15049, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416072968, &quot;name&quot;: &quot;userNum-1&quot;, &quot;parentType&quot;: &quot;object&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;userNum&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1002&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 4560, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;1002002&quot;, &quot;id&quot;: 97300, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;id&quot;: 52444, &quot;parentName&quot;: &quot;userNum&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 91376 &#125;, &#123; &quot;name&quot;: &quot;loginStatus&quot;, &quot;protoName&quot;: &quot;login_status&quot;, &quot;type&quot;: &quot;services.LoginStatus&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;success&quot;, &quot;isExpand&quot;: false, &quot;children&quot;: [], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 43622 &#125;, &#123; &quot;name&quot;: &quot;phones&quot;, &quot;protoName&quot;: &quot;phones&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneNumber&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: true, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;id&quot;: 1600416104944, &quot;name&quot;: &quot;phones-0&quot;, &quot;parentType&quot;: &quot;array&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;phones&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;12345678900&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 68179, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;value&quot;: &quot;mobile&quot;, &quot;id&quot;: 49819, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;, &#123; &quot;id&quot;: 1600416117567, &quot;name&quot;: &quot;phones-1&quot;, &quot;parentType&quot;: &quot;array&quot;, &quot;flag&quot;: &quot;append&quot;, &quot;parentName&quot;: &quot;phones&quot;, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;12345678911&quot;, &quot;value&quot;: &quot;&quot;, &quot;id&quot;: 4276, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot;, &quot;value&quot;: &quot;mobile&quot;, &quot;id&quot;: 62179, &quot;parentName&quot;: &quot;phones&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 3, &quot;bLeft&quot;: 50, &quot;operator&quot;: &quot;&quot; &#125;], &quot;isExpand&quot;: true, &quot;level&quot;: 2, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34 &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 16793 &#125;, &#123; &quot;name&quot;: &quot;lastUpdateDate&quot;, &quot;protoName&quot;: &quot;last_update_date&quot;, &quot;type&quot;: &quot;google.protobuf.Timestamp&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null, &quot;isExpand&quot;: true, &quot;children&quot;: [&#123; &quot;name&quot;: &quot;seconds&quot;, &quot;protoName&quot;: &quot;seconds&quot;, &quot;type&quot;: &quot;int64&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;123&quot;, &quot;value&quot;: &quot;0&quot;, &quot;id&quot;: 32046, &quot;parentName&quot;: &quot;lastUpdateDate&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;bLeft&quot;: 34, &quot;operator&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;nanos&quot;, &quot;protoName&quot;: &quot;nanos&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;222&quot;, &quot;value&quot;: 0, &quot;id&quot;: 27909, &quot;parentName&quot;: &quot;lastUpdateDate&quot;, &quot;isExpand&quot;: true, &quot;children&quot;: [], &quot;level&quot;: 2, &quot;bLeft&quot;: 34, &quot;operator&quot;: &quot;&quot; &#125;], &quot;level&quot;: 1, &quot;operator&quot;: &quot;&quot;, &quot;bLeft&quot;: 34, &quot;id&quot;: 60223 &#125;], &quot;services.UserLoginRequest.PhoneNumber&quot;: [&#123; &quot;name&quot;: &quot;phoneNumber&quot;, &quot;protoName&quot;: &quot;phone_number&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;phoneType&quot;, &quot;protoName&quot;: &quot;phone_type&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneType&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: true, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;mobile&quot; &#125;], &quot;services.UserLoginRequest.UserEmailEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;], &quot;services.UserLoginRequest.UserNumEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;services.UserLoginRequest.PhoneNumber&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: true, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: null &#125;], &quot;services.UserLoginRequest.UserWeightEntry&quot;: [&#123; &quot;name&quot;: &quot;key&quot;, &quot;protoName&quot;: &quot;key&quot;, &quot;type&quot;: &quot;string&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;value&quot;, &quot;protoName&quot;: &quot;value&quot;, &quot;type&quot;: &quot;int32&quot;, &quot;oneOfFields&quot;: null, &quot;isMessage&quot;: false, &quot;isEnum&quot;: false, &quot;isArray&quot;: false, &quot;isMap&quot;: false, &quot;isRequired&quot;: false, &quot;defaultVal&quot;: 0 &#125;] &#125;, &quot;enumTypes&quot;: &#123; &quot;services.LoginStatus&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;success&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;failed&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;error&quot; &#125;], &quot;services.UserLoginRequest.Hobby&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;music&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;basketball&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;tour&quot; &#125;], &quot;services.UserLoginRequest.PhoneType&quot;: [&#123; &quot;num&quot;: 0, &quot;name&quot;: &quot;mobile&quot; &#125;, &#123; &quot;num&quot;: 1, &quot;name&quot;: &quot;home&quot; &#125;, &#123; &quot;num&quot;: 2, &quot;name&quot;: &quot;work&quot; &#125;] &#125;&#125; parse_test.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/*** @author : hqd8080* @description : json转换* @date : 2021-05-15 21:56 */package testimport ( &quot;io/ioutil&quot; &quot;strconv&quot; &quot;testing&quot; &quot;time&quot; &quot;github.com/bitly/go-simplejson&quot;)func TestParseJSON(t *testing.T) &#123; data, err := ioutil.ReadFile(&quot;./request.json&quot;) if err != nil &#123; t.Log(err) &#125; js, err := simplejson.NewJson(data) requestType := js.Get(&quot;requestType&quot;).MustString() messageType := js.Get(&quot;messageTypes&quot;).Get(requestType) t.Log(&quot;count:&quot;, len(messageType.MustArray())) result := parseJSON(t, messageType) ret, err := result.EncodePretty() if err != nil &#123; t.Log(err) &#125; t.Log(string(ret))&#125;func parseJSON(t *testing.T, sourceJson *simplejson.Json) *simplejson.Json &#123; resultJson := simplejson.New() if len(sourceJson.MustArray()) &gt; 0 &#123; for i := 0; i &lt; len(sourceJson.MustArray()); i++ &#123; item := sourceJson.GetIndex(i) if len(item.Get(&quot;children&quot;).MustArray()) &gt; 0 &#123; if item.Get(&quot;isMap&quot;).MustBool() == true &#123; // t.Log(&quot;is map&quot;, item.Get(&quot;name&quot;).MustString()) data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() newMap := make(map[string]interface&#123;&#125;) for _, m := range dataMap &#123; mm, ok := m.(map[string]interface&#123;&#125;) if ok &#123; if len(mm) &gt; 2 &#123; nn := make(map[string]interface&#123;&#125;) for k, v := range mm &#123; if k == &quot;key&quot; &#123; continue &#125; nn[k] = v &#125; newMap[mm[&quot;key&quot;].(string)] = nn &#125; else &#123; newMap[mm[&quot;key&quot;].(string)] = mm[&quot;value&quot;] &#125; &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), newMap) &#125; else if item.Get(&quot;isArray&quot;).MustBool() == true &#123; // t.Log(&quot;isArray:&quot;, item.Get(&quot;name&quot;).MustString()) data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() newMap := make([]interface&#123;&#125;, 0) for _, m := range dataMap &#123; arr, ok := m.([]interface&#123;&#125;) if ok &#123; for _, v := range arr &#123; newMap = append(newMap, v) &#125; &#125; mm, ok := m.(map[string]interface&#123;&#125;) if ok &#123; newMap = append(newMap, mm) &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), newMap) &#125; else &#123; data := parseJSON(t, item.Get(&quot;children&quot;)) dataMap, _ := data.Map() resultJson.Set(item.Get(&quot;name&quot;).MustString(), dataMap) if item.Get(&quot;type&quot;).MustString() == &quot;google.protobuf.Timestamp&quot; &#123; // t.Log(item.Get(&quot;name&quot;).MustString()) var seconds, nanos int64 for _, t := range item.Get(&quot;children&quot;).MustArray() &#123; if row, ok := t.(map[string]interface&#123;&#125;); ok &#123; if field, ok := row[&quot;name&quot;].(string); ok &#123; switch field &#123; case &quot;seconds&quot;: seconds, _ = strconv.ParseInt(row[&quot;defaultVal&quot;].(string), 10, 64) case &quot;nanos&quot;: nanos, _ = strconv.ParseInt(row[&quot;defaultVal&quot;].(string), 10, 64) &#125; &#125; &#125; &#125; resultJson.Set(item.Get(&quot;name&quot;).MustString(), time.Unix(seconds, nanos).UTC().String()) &#125; &#125; &#125; else &#123; // t.Log(item.Get(&quot;name&quot;).MustString()) var defaultVal interface&#123;&#125; if item.Get(&quot;type&quot;).MustString() == &quot;bool&quot; &#123; defaultVal = item.Get(&quot;defaultVal&quot;).MustBool() &#125; else &#123; defaultVal = convertDefaultVal(item.Get(&quot;type&quot;).MustString(), item.Get(&quot;defaultVal&quot;).MustString()) &#125; if item.Get(&quot;name&quot;).MustString() == &quot;&quot; &#123; array := resultJson.Get(&quot;array&quot;).MustArray() array = append(array, defaultVal) resultJson.Set(&quot;array&quot;, array) &#125; else &#123; resultJson.Set(item.Get(&quot;name&quot;).MustString(), defaultVal) &#125; &#125; &#125; &#125; return resultJson&#125;func convertDefaultVal(t string, v string) interface&#123;&#125; &#123; switch t &#123; case &quot;int32&quot;, &quot;int64&quot;: i, _ := strconv.Atoi(v) return i case &quot;string&quot;: return v case &quot;bytes&quot;: return []byte(v) case &quot;float&quot;, &quot;double&quot;: f, _ := strconv.ParseFloat(v, 32) return f default: return v &#125;&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"gRPC学习笔记","slug":"grpc/grpc","date":"2020-05-14T12:59:30.000Z","updated":"2021-11-29T03:53:37.000Z","comments":true,"path":"2020/05/14/grpc/grpc/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/grpc/grpc/","excerpt":"","text":"gRPC学习笔记gRPC是一个高性能，开源，通用的RPC框架；由google开发；基于HTTP/2协议设计开发；采用protobuf数据序列化协议； 特点： 1.gRPC使用protobuf来定义服务，接口，和数据类型； 2.gRPC基于HTTP/2标准设计；高性能：双向流；头部压缩；多路复用等；对移动设备友好；节省带宽；降低TCP连接次数；提高CPU利用率； gRPC可以定义4种类型的服务接口： 1.一元RPC 2.服务端流RPC 3.客户端流式RPC 4.双向流式RPC 生成Go客户端和服务端代码： 1protoc --go_out=plugins=grpc:. pb/user.proto 使用流式编程的特点：向客户端或者服务器发送批量的数据。可以不用等待所有的消息全部接收后才开始响应；而是接收到第一条消息的时候及时响应;从而减少服务的延迟； 服务端采用流式响应：send客户端采用流式调用：recv 双向流RPC调用和客户端流RPC调用的区别：双向流：客户端发送一个请求数据后；立马就可以获取对应的服务端响应客户端流：会先将客户端的请求以流的形式发送完毕，再获取服务端的响应 HTTP/2（4大新特性） 1.二进制传输HTTP/2传输数据量的大幅减少,主要有两个原因：以二进制方式传输和Header压缩HTTP/2将请求和响应数据分割为更小的帧，并且它们采用二进制编码； 2.Header压缩(头部压缩) 3.多路复用在HTTP/2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度 4.Server Push（服务器推送）HTTP/2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push） 例子：hello.proto 123456789101112131415161718192021syntax = &quot;proto3&quot;;package services;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125;service HelloService &#123; rpc SayHello(HelloRequest) returns (HelloReply);&#125;// client.gogrpc.Dial(*addr, grpc.WithInsecure())// server.gol, err := net.Listen(&quot;tcp&quot;, *addr)srv := grpc.NewServer() gRPC是基于HTTP/2协议设计开发（长连接），减少网络延迟，服务器维护连接状态，不用频繁的创建连接带来的开销。HTTP2 是一个全双工的流式协议, 服务端也可以主动 ping 客户端, 且服务端还会有一些检测连接可用性和控制客户端 ping 包频率的配置。gRPC 就是采用 HTTP2 来作为其基础通信模式的，所以默认的 gRPC 客户端都是长连接 2 长连接的优势（keepalive） 相比于短连接，长连接具有：较低的延时。由于跳过了三次握手的过程，长连接比短连接有更低的延迟。较低的带宽占用。由于不用为每个请求建立和关闭连接，长连接交换效率更高，网络带宽占用更少。较少的系统资源占用。server 为了维持连接，会为每个连接创建 socket，分配文件句柄， 在内存中分配读写 buffer，设置定时器进行 keepalive。因此更少的连接数也意味着更少的资源占用。 另外， gRPC 使用 HTTP/2.0 作为传输协议， 从该协议的设计来讲， 长连接也是更推荐的使用方式。","categories":[{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"}]},{"title":"Go语言结构体转字典实例","slug":"golang/go-struct-to-map","date":"2020-05-14T12:59:30.000Z","updated":"2022-11-19T08:07:54.463Z","comments":true,"path":"2020/05/14/golang/go-struct-to-map/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-struct-to-map/","excerpt":"","text":"结构体转字典实例1column := c.GetStrings(&quot;column&quot;) 1234567891011121314list, count, err := services.NewGcase(services.Slave()).CaseList(NewContext(), params, pageSize, pageNum) if err != nil &#123; c.ErrorCode(ErrCodeRet, http.StatusInternalServerError, &quot;get case list failed&quot;) &#125; res := make([]map[string]interface&#123;&#125;, 0) for _, item := range list &#123; res = append(res, structConvertMapByTag(item, &quot;json&quot;, column)) &#125; ret := make(map[string]interface&#123;&#125;, 0) ret[&quot;data&quot;] = res ret[&quot;count&quot;] = count c.Correct(ret) 123456789101112131415161718192021222324252627func structConvertMapByTag(obj interface&#123;&#125;, tagName string, col []string) map[string]interface&#123;&#125; &#123; t := reflect.TypeOf(obj) v := reflect.ValueOf(obj) var data = make(map[string]interface&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; if len(col) &gt; 0 &#123; for _, item := range col &#123; tagName := t.Field(i).Tag.Get(tagName) if tagName == item &#123; fmt.Println(tagName) if tagName != &quot;&quot; &amp;&amp; tagName != &quot;-&quot; &#123; data[tagName] = v.Field(i).Interface() &#125; &#125; &#125; &#125; else &#123; // 不设置列的时候显示所有字段 tagName := t.Field(i).Tag.Get(tagName) if tagName != &quot;&quot; &amp;&amp; tagName != &quot;-&quot; &#123; data[tagName] = v.Field(i).Interface() &#125; &#125; &#125; return data&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言计算字符串长度（包含汉字）","slug":"golang/go-runecountInstring","date":"2020-05-14T12:56:28.000Z","updated":"2022-11-19T08:07:54.431Z","comments":true,"path":"2020/05/14/golang/go-runecountInstring/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-runecountInstring/","excerpt":"","text":"Go语言计算字符串长度（包含汉字）中英文混合1234567891011package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() &#123; count := utf8.RuneCountInString(&quot;Go语言计算字符串长度,中英文&quot;) fmt.Print(count) &#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的GC垃圾回收","slug":"golang/go-gc","date":"2020-05-14T12:49:40.000Z","updated":"2022-11-19T08:07:54.423Z","comments":true,"path":"2020/05/14/golang/go-gc/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-gc/","excerpt":"","text":"Go语言的GC垃圾回收GC垃圾回收GC是一种自动管理内存的机制，垃圾回收器会尝试回收程序不再使用的对象和占用的内存在程序中设置GC的触发频率debug.SetGCPercent 垃圾回收算法： 1.引用计数 2.标记-清除 Go采用三色标记法 3.分代收集 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象优点：对象可以很快被回收缺点：不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价代表语言：php，python 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的变量被回收优点：解决引用计数的缺点，不能很好的处理循环引用，而且实时的维护引用计数也有一定的代价的缺点缺点：暂停程序的执行代表语言：Go （三色标记法） 分代收集按照对象生命周期的长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率优点：收回性能好缺点：算法复杂代表语言:java Go的垃圾回收Go垃圾回收的原理是，标记出哪些内存还在使用中，（即被引用到），哪些内存不在使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时再使用缺点就是，不是实时的回收内存，而是暂停程序的执行去处理内存回收 三色标记法这里的三色是对应了垃圾回收过程中对象的三种状态1.灰色：对象还在标记队列中等待2.黑色：对象已经被标记(该对象不会在本次GC中被清理)3.白色：对象未被标记(该对象会在本次GC中被清理) Go的STWGo中的STW（Stop The World）就是停止所有的goroutine，专心做垃圾回收，待垃圾回收结束后，再恢复goroutine,STW的长短直接影响了程序的性能 垃圾回收优化1.写屏障就是让goroutine与GC同时运行的手段，GC过程中新分配的内存会被立即标记，即本轮不回收，下次GC时再确定 2.补助GC使用goroutine参与一部分的GC工作来提高性能 垃圾回收的触发时机1.内存分配量达到阈值触发GC每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值则立即触发GC阈值 = 上次GC内存分配量 X 内存增长率内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC 2.定期触发GC默认情况下，最长两分钟触发一次GC 3.手动触发使用 runtime.GC() 来手动触发GC主要用于GC的性能测试和统计 逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定 在函数中申请一个新的对象：如果分配在栈中，则函数执行结束后，可自动将内存回收如果分配在堆中，则函数执行结束后可交给GC（垃圾回收）处理 1.逃逸策略在函数中申请新的对象时，编辑器会根据该对象是否被函数外部引用来决定是否逃逸：如果函数外部没有引用，则优先放在栈中如果函数外部存在引用，则必定存放在堆中 注意：对于仅在函数内部使用的变量，也有可能存放在堆中，比如内存过大，超过栈的存储能力 使用interface类型存在逃逸的可能（动态类型逃逸）闭包引用对象逃逸","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言的交叉编译","slug":"golang/go-gobuild","date":"2020-05-14T12:49:40.000Z","updated":"2022-11-19T08:07:54.457Z","comments":true,"path":"2020/05/14/golang/go-gobuild/","link":"","permalink":"https://hqd8080.github.io/2020/05/14/golang/go-gobuild/","excerpt":"","text":"Go语言的交叉编译在不同的系统打包编译的命令 12#-o：指定编译后的二进制包名称GOOS=linux GOARCH=amd64 go build -o app main.go 123#编译windows的exe文件#亲测有效，自己的开发本本是macOSCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o test.exe main.go","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]},{"title":"Go语言生产者和消费者模式","slug":"golang/go-producer-consumer","date":"2020-01-02T03:17:10.000Z","updated":"2022-11-19T08:07:54.434Z","comments":true,"path":"2020/01/02/golang/go-producer-consumer/","link":"","permalink":"https://hqd8080.github.io/2020/01/02/golang/go-producer-consumer/","excerpt":"","text":"Go语言使用chan实现生产者和消费者代码12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;// 消费者func consumer(data chan int, done chan bool) &#123; // 接收数据，直到通道被关闭 for v := range data &#123; fmt.Println(&quot;recv:&quot;, v) &#125; // 通知main消费结束 done &lt;- true&#125;// 生产者func producer(data chan int) &#123; for i := 0; i &lt; 4; i++ &#123; // 发送数据 data &lt;- i &#125; // 生产结束，关闭通道 close(data)&#125;func main() &#123; done := make(chan bool) // 用于接收消费者结束信号 data := make(chan int) // 数据管道 go consumer(data, done) // 启动消费者 go producer(data) // 启动生产者 &lt;-done // 阻塞，直到消费者发回结束信号&#125; 1234recv: 0recv: 1recv: 2recv: 3","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"}]}],"categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://hqd8080.github.io/categories/Go%E8%AF%AD%E8%A8%80/"},{"name":"Docker","slug":"Docker","permalink":"https://hqd8080.github.io/categories/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"https://hqd8080.github.io/categories/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://hqd8080.github.io/categories/Linux/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/categories/gRPC/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/categories/go-zero/"},{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/categories/MySQL/"},{"name":"Git","slug":"Git","permalink":"https://hqd8080.github.io/categories/Git/"},{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Redis","slug":"Redis","permalink":"https://hqd8080.github.io/categories/Redis/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hqd8080.github.io/tags/golang/"},{"name":"gorm","slug":"gorm","permalink":"https://hqd8080.github.io/tags/gorm/"},{"name":"docker","slug":"docker","permalink":"https://hqd8080.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://hqd8080.github.io/tags/redis/"},{"name":"nginx","slug":"nginx","permalink":"https://hqd8080.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"https://hqd8080.github.io/tags/linux/"},{"name":"gRPC","slug":"gRPC","permalink":"https://hqd8080.github.io/tags/gRPC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hqd8080.github.io/tags/MySQL/"},{"name":"go-zero","slug":"go-zero","permalink":"https://hqd8080.github.io/tags/go-zero/"},{"name":"区块链","slug":"区块链","permalink":"https://hqd8080.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"blockchain","slug":"blockchain","permalink":"https://hqd8080.github.io/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://hqd8080.github.io/tags/ethereum/"},{"name":"solidity","slug":"solidity","permalink":"https://hqd8080.github.io/tags/solidity/"},{"name":"webSocket","slug":"webSocket","permalink":"https://hqd8080.github.io/tags/webSocket/"},{"name":"git","slug":"git","permalink":"https://hqd8080.github.io/tags/git/"},{"name":"微服务","slug":"微服务","permalink":"https://hqd8080.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"microservice","slug":"microservice","permalink":"https://hqd8080.github.io/tags/microservice/"}]}